<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1124赣州</title>
      <link href="/2025/11/24/1124%E8%B5%A3%E5%B7%9E/"/>
      <url>/2025/11/24/1124%E8%B5%A3%E5%B7%9E/</url>
      
        <content type="html"><![CDATA[<p>2025.11.23晚<br>目前还在回广的火车上，心情百感交集，跟你两天在赣州相会，让我深醉其中。让我愈加喜欢你，深爱你，一种我对你更加了解，坦然。周五下午旷课跑去见你的，路上的久坐难耐，在到达赣州站的一刻都消散，一种奔赴爱人的决心和爱意。此前，我一直觉得我们缺少一次正式的表白，这也是这些没见的日子里纠结的问题，虽然源于目前资金受限，但不妨碍我对你倾尽所有的心。一个小小的魔术，一篇简单的“录用邮件”，一个副驾驶的鲜花，都是你值得的拥有。很庆幸所有的一切时间都安排妥当，恰逢我的杨小姐也喜欢。<br>第一天给到我蛮多很妙的感觉，毕竟第二天容易陷入离别的焦虑，让我们内心涟漪。一起开着车游逛这座小城，给我BB累坏了，在副驾频频入睡，但跟BB一起的我一直乐此不疲，看着熟睡的你，这一刻非常幸福，以后也必将如此！<br>印象深刻的是回到酒店被那个煞笔车挡路停车时，你是我唯一的信任，遇到无理老太你会竞争，虽然是小事一桩，但两个敢做敢竞争互相信任支持，有什么是做不到做不成功的呢！<br>也许是不服水土肠胃作祟，那晚突然变冷，吹的肚子闹腾影响进度，我随口的一句可能肠炎犯了，对于我来说原本小事一桩，让我没想到的是你去给我买药，完全的意料之外，除了妈妈外，有个对我这么在意对我这么关心的人你是第一个。<br>虽然有些事情不愉快，但我们坦诚坦白就都不是事，我相信只要一起妥善解决，这只会是感情升华的助燃剂</p><p>我们复盘说的，如若广州行有一方不够勇敢大胆，也许就没有现如今</p>]]></content>
      
      
      <categories>
          
          <category> 老婆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaEE加强</title>
      <link href="/2025/11/15/javaEE%E5%8A%A0%E5%BC%BA/"/>
      <url>/2025/11/15/javaEE%E5%8A%A0%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="javaEE基础加强"><a href="#javaEE基础加强" class="headerlink" title="javaEE基础加强"></a>javaEE基础加强</h3><ol><li>异常，泛型，集合框架</li><li>stream流</li><li>File，字符集，IO流框架</li><li>多线程</li><li>网络编程</li><li>java高级技术</li></ol><h3 id="异常体系（java-lang-Throuable）"><a href="#异常体系（java-lang-Throuable）" class="headerlink" title="异常体系（java.lang.Throuable）"></a>异常体系（java.lang.Throuable）</h3><p>Error：是系统级别的异常，Sun公司自己用的</p><p>Exception（开发人员控制）：</p><ul><li>Runtime Exception:运行异常</li><li>其他异常（红线提醒）</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用try（）{}catch{} 捕获异常，（）内为执行后close（）线程部分，可以省略</span></span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    </span><br><span class="line">}<span class="keyword">catch</span>(Exception e){</span><br><span class="line">    e.  <span class="comment">// 调用打印输出异常内容</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctrl+enter将异常抛出到上一层</span></span><br></pre></td></tr></tbody></table></figure><p>tip：idea中ctrl + alt + t 快速创建try{…}catch{…}</p><p>异常作用：</p><p>可以作为方法的一种特殊返回值，以便通知上层调用者方法执行问题(外抛异常： <code>throw   new  Exception(" ");</code>)</p><p>异常：代码编译或运行时可能出现的错误</p><p>自定义异常:</p><p>java无法为世界上全部问题提供异常类来代表（java目前逐步放弃编译异常，以运行异常为主）</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li>抛出异常提示信息</li><li>最外层捕获异常后，尝试修复</li></ol><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义类，接口，方法时，同时声明了一个或多个类型变量（如：<e> ）</e></p><p>作用：在编译阶段约束所能操作的数据类型，并自动进行检查能力</p><p>本质：把具体的变量类型传给类型变量</p><p><strong>泛型接口方法（架构师）</strong>：</p><p>建类变量用 E（元素类型），T（返回Type），K（键类型），V（值类型）全部大写</p><p>方法，通配符，上下限</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> (name) (T (name))</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T (name) (T (name))</span><br></pre></td></tr></tbody></table></figure><p>tip:通配符就是“？”  可以使用泛型代表一切类型，ETKV是定义泛型时使用</p><p><strong>通配符问题，其他什么狗也能进来，于是引出上下限</strong></p><p>泛型上限：<code>? extends Car:?</code>  能接Car或其子类</p><p>泛型下限：<code>? super Car:?</code>  能接Car或其父类</p><p><strong>泛型不支持的基本数据类型，只支持对象类型（引用数据类型）</strong></p><p>解决方式（包装类），万物皆对象的思想</p><p>基本数据类型包装成对象的类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> -&gt; Integer</span><br><span class="line"><span class="type">char</span> -&gt; Character </span><br><span class="line"><span class="comment">// 其他基本是首字母大写</span></span><br><span class="line"><span class="comment">// 这就转成了对象类型</span></span><br></pre></td></tr></tbody></table></figure><p>手动包装：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">it1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>); <span class="comment">// -128~127 源码</span></span><br><span class="line">it1 == it2;  <span class="comment">//一个cache缓存</span></span><br></pre></td></tr></tbody></table></figure><p>自动装箱：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add();  <span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.get(); <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></tbody></table></figure><p>Api：</p><p><code>Integer.parseInt(String s)</code> 把字符串类型的数值转换成数值本身对应的真实类型</p><p><code>Integer.valueOf(String s)</code>  把基本数据类型转字符串类型</p><p><code>toString(double d)</code></p><p><code>toString()</code></p><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>（Collection/Map两大框架）</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection<e></e></h3><ul><li>list<e><ol><li>ArrayList<e></e></li><li>LinkedList<e></e></li></ol></e></li><li>set<e><ol><li>HashSet<e>  -&gt;  LinkedHashSet<e></e></e></li><li>TreeSet<e></e></li></ol></e></li></ul><p>List集合：添加元素有序，可重复，有索引</p><p>Set集合：无序，不重复，无索引（LinkedHashSet除外）</p><p><strong>常用方法：</strong></p><p><code>add(E e)</code> 添加</p><p><code>clear()</code>  清除所有元素</p><p><code>remove(E e)</code>  指定对象在集合中删除</p><p><code>contains(Object obj)</code>  判断是否含指对象</p><p><code>isEmpty()</code>  判断是否为空</p><p><code>toArray()</code>  把集合中元素，存储到数组中</p><p>collection家族的3种遍历方式：</p><p>​迭代器是用来遍历集合的专用方式，java的迭代器代表是Iterator</p><p><strong>方法名：</strong></p><p>​<code>hasNext()</code>  询问当前元素，存返回true  or  false（源码是 <code>return (name)  != size;</code> 索引来判断）</p><p>​<code>E Next()</code>    获元素位置，并指向下一元素</p><p><strong>方式2：</strong></p><p><em><strong>增强for循环遍历</strong></em> for(元素的数据类型  变量名  ： 数组/集合{})</p><p><strong>方式3:</strong></p><p><em><strong>Lambda表达式</strong></em>（JDK8开始）forEach（） 结合Lambda遍历集合</p><p>3种遍历方式区别：<strong>并发修改异常问题</strong> </p><ol><li>补位（index） 方式一，做一个 <code>i--</code> 操作</li><li>无需<code>i--</code> 做倒序遍历方式</li></ol><p>2种迭代器（适用于无索引的情况）</p><p>tip： it.remove() 使用迭代器删除，不用list</p><p><strong>总结：</strong>增强for和Lambda只适合遍历（无法解决并发修改异常问题），不适合遍历并删除</p><p>​有索引，用for循环</p><p>​无索引，用迭代器删除</p><p><strong>ArrayList 底层基于数组存储数据（查询慢，从头开始遍历）</strong></p><p><strong>LinkedList 底层基于双链表（查询速度快，增删快，折半算法）</strong></p><p><strong>新增方法：</strong></p><ul><li><code>addFirst()</code>  头插元素</li><li><code>addLast()</code>  尾插元素</li><li><code>get...</code></li><li><code>remove...</code></li></ul><p>！！！ 独立功能，独立成方法！！！</p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set<e> 集合</e></h3><p>HashSet：无序，不重复，无索引</p><p>LinkedHashSet：有序，不重复，无索引</p><p>TreeSet：排序，不重复，无索引</p><p><em><strong>底层原理：</strong></em></p><p>哈希值：一个<code>int</code>类型的随机值，java中每一个对象都有一个哈希值</p><p>java中所有对象，都可以调用Object类提供的HashCode方法，返回对象自己的哈希值</p><p><strong>不同对象，它们的哈希值大概率不相等，但可能相等（哈希碰撞）  int(-21亿~21亿多)</strong></p><p><em>HashSet底层：基于哈希表存储，</em></p><p>JDK8前：哈希表 = 数组 + 链表</p><p>JDK8后：哈希表 = 数组 + 链表 + 红黑树  （增删改查性能更佳）</p><table><thead><tr><th>Null</th><th>… …..</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>……….</td><td>16</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li>new 后创建一个长度为16的数组，默认加载因子为0.75（16x0.75=12，默认到12扩容），数组名为table（tip：k8后，链表长度超过8，数组长度&gt;=64，自动转红黑树）</li><li>使用元素的哈希值（随机）对数组长度做运算，计算处应存入的位置</li><li>判断为NULL直接存入</li><li>不为NULL，表示有元素，调用equals方法比较相等，不存在不相等则存入</li></ol><p>tip：k8前，占老元素位置，k8后，挂老元素下面</p><h3 id="LinkedHashSet底层原理"><a href="#LinkedHashSet底层原理" class="headerlink" title="LinkedHashSet底层原理"></a>LinkedHashSet底层原理</h3><ol><li>基于哈希表（数组+链表+红黑树）</li><li>加了双链表机制记录前后元素位置（有序）</li></ol><p><strong>TreeSet集合一点要排序，解决无默认比较2种方法：</strong></p><ol><li>对象类型实现一个Comparable 比较接口，重写compare方法，指定比较大小规则</li><li><code>public TreeSet(Comparable c)</code> 集合自带比较器 Comparetor对象（实现<code>implements  Comparable&lt;E&gt;</code> 接口,重写ComparableTo（）方法）</li></ol><p><strong>规则：</strong></p><ol><li>t2.compareTo(t1)左&gt;右，返回正整数</li><li>t2 == this  比较者         左&lt;右，返回负整数</li><li>t1  == 0    被比较者        返回0</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetDemo3</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 目标：搞清楚TreeSet集合对于自定义对象的排序</span></span><br><span class="line">        Set&lt;Teacher&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Teacher&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Teacher o1, Teacher o2)</span> {</span><br><span class="line">                <span class="comment">//return o1.getAge() - o2.getAge(); // 升序,装逼写法有风险</span></span><br><span class="line">                <span class="keyword">return</span> Double.compare(o1.getAge(),o2.getAge()); <span class="comment">// 包装类底层方法</span></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// Set&lt;Teacher&gt; set = new TreeSet&lt;&gt;((o1,o2) -&gt; Double.compare(o1.getAge(),o2.getAge()))</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">"刘总"</span>,<span class="number">20</span>,<span class="number">6230.4</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">"杨总"</span>,<span class="number">18</span>,<span class="number">3000.2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">"张总"</span>,<span class="number">20</span>,<span class="number">1999.9</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结论：treeSet集合默认不能给自定义对象排序，因为不知道大小规则。</span></span><br><span class="line">        <span class="comment">// 结局两种方案</span></span><br><span class="line">        <span class="comment">// 1.对象实现Comparable比较接口，重写compare方法，指定大小比较规则。</span></span><br><span class="line">        <span class="comment">// 2.让TreeSet集合自带comparator自带比较器对象。指定大小比较规则</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="collection-–-Map"><a href="#collection-–-Map" class="headerlink" title="collection   –   Map"></a>collection   –   Map</h3><p>单例集合   –   双列集合（键值对集合）</p><p>Map&lt;K,V&gt;    （接口）:</p><ol><li><p>HashMap&lt;K,V&gt;   （无序，不重复，无索引）</p><p>LinkedHashMap&lt;K,V&gt;  (有序，不重复，无索引)</p></li><li><p>TreeMap&lt;K,V&gt;   （实现类，按大小默认升序，不重复，无索引）</p></li></ol><p>Map集合遍历方式1：键值对</p><p>​定一个keys存键集合，遍历键调用get（）方法找值</p><p>​增强for（元素类型  变量  ： 集合）{}</p><p>2，键值对方式：</p><p>​java提供的<code>entrySet()</code> 方法（获取所有键值对集合）</p><p>​再用增强for，调用<code>getkey（）</code>，<code>getValue()</code>方法调用</p><p>3，Lambda表达式</p><p>​调用Map方法<code>forEach（）</code> ，里<code>new BiComsumer()</code>  方法重写输出</p><p>增强for遍历：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 目标：掌握map集合，map常用方法</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"嫦娥"</span>,<span class="number">20</span>);</span><br><span class="line">        map.put(<span class="string">"女儿国王"</span>,<span class="number">31</span>);</span><br><span class="line">        map.put(<span class="string">"嫦娥"</span>,<span class="number">28</span>);</span><br><span class="line">        map.put(<span class="string">"铁扇公主"</span>,<span class="number">38</span>);</span><br><span class="line">        map.put(<span class="string">"紫霞"</span>,<span class="number">31</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(<span class="string">"嫦娥"</span>));</span><br><span class="line">        System.out.println(map.containsKey(<span class="string">"嫦娥"</span>));</span><br><span class="line">        System.out.println(map.containsValue(<span class="number">28</span>));</span><br><span class="line">        System.out.println(map.remove(<span class="string">"嫦娥"</span>)); <span class="comment">// 根据键删除整个键值对</span></span><br><span class="line"><span class="comment">//        map.clear();</span></span><br><span class="line"><span class="comment">//        System.out.println(map);</span></span><br><span class="line">        System.out.println(map.isEmpty()); <span class="comment">// 判断是否为空</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(String key : keys){</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是一种多态写法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest6</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 目标：完成map集合相关案例，投票统计程序</span></span><br><span class="line">        calc();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 1.把80个学生选择的景点数据拿到程序中，才能统计</span></span><br><span class="line">        List&lt;String&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] names = {<span class="string">"天安门"</span>,<span class="string">"西安"</span>,<span class="string">"厦门"</span>,<span class="string">"上海"</span>};</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rs</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">80</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> rs.nextInt(names.length);</span><br><span class="line">            locations.add(names[index]);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(locations);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.统计每个景点被选择的次数</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="keyword">for</span> (String location : locations){</span><br><span class="line"><span class="comment">//            if (map.containsKey(location)){</span></span><br><span class="line"><span class="comment">//                map.put(location,map.get(location) + 1);</span></span><br><span class="line"><span class="comment">//            }else{</span></span><br><span class="line"><span class="comment">//                map.put(location,1);</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line">            <span class="comment">// 三元运算符优化代码</span></span><br><span class="line">            map.put(location,map.containsKey(location) ? map.get(location) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 把map集合遍历出来</span></span><br><span class="line">        map.forEach((k,v) -&gt; System.out.println(k + <span class="string">"被选择了"</span> + v + <span class="string">"次"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p>JDk8开始，可以用于操作集合或数组的数据</p><p>优势：Stream流大量结合了Lambda语法风格，代码简介，可读性好</p><p>Api：<code>startWith() </code>方法，判断字符串是否有某个字符</p><p>用法：</p><p>​1.调用<code>stream（）</code>方法（集合调用）</p><ul><li>list.stream()  类似工厂传送带</li><li>.flters()   过滤器（可选调）</li><li>.collect()   收集到新list</li></ul><p><strong>获取stream（）流方法</strong></p><p>​集合stream()</p><p>​数组stream() 获当前数组的stream流</p><p>​of()  获取当前接受数据的stream流</p><p>​.count()   计算Arrays中数据个数</p><p><strong>工作模式： 数据源（集合/数组/….）  -&gt;  过滤-排序-去重-….(中间方法)  -&gt;  获取结果</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collector;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 认识stream流，掌握基本使用步骤，体会优势和特点</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        list.add(<span class="string">"赵敏"</span>);</span><br><span class="line">        list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">        list.add(<span class="string">"张三丰"</span>);</span><br><span class="line">        list.add(<span class="string">"张翠山"</span>);</span><br><span class="line">        list.add(<span class="string">"张强"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.传统方案找法,创建姓张的新集合</span></span><br><span class="line">        List&lt;String&gt; newList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String name : list){</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>) &amp;&amp; name.length() == <span class="number">3</span>){</span><br><span class="line">                newList.add(name);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(newList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.使用stream流解决</span></span><br><span class="line">        List&lt;String&gt; newlist2 = list.stream().filter(name -&gt; name.startsWith(<span class="string">"张"</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(newlist2);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>操作（stream）：</strong></p><ul><li>filter – 过滤</li><li>sorted  – 元素进行升序排序</li><li>sorted(Comparator  &lt;?  super  T&gt;  Comparator)  –  指定排序规则</li><li>limit(long  maxsize)   获取前几个元素</li><li>skip(long  n)   跳过前几个元素</li><li>distinct()   去除流中重复元素</li><li>map    对流加工，返回新流</li><li>concat(stream  a, stream  b)   合并a，b为一个流</li></ul><p>tip：流只能收集一次</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collector;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 获取Stream流</span></span><br><span class="line">        <span class="comment">// 1.获取集合的Stream流的方法，调用集合提供的Stream（）方法</span></span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; s1 = list.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.map集合，怎么拿Stream流</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 单独获取键流,调用keySet（）</span></span><br><span class="line">        Stream&lt;String&gt; s2 = map.keySet().stream();</span><br><span class="line">        <span class="comment">// 获取值流</span></span><br><span class="line">        Stream&lt;Integer&gt; s3 = map.values().stream();</span><br><span class="line">        <span class="comment">// 获取键值对流</span></span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; s4 = map.entrySet().stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3。数组调用stream流</span></span><br><span class="line">        String[] names = {<span class="string">"张三丰"</span>,<span class="string">"张无忌"</span>,<span class="string">"张翠山"</span>,<span class="string">"张良"</span>,<span class="string">"张学友"</span>};</span><br><span class="line">        Stream&lt;String&gt; s5 = Arrays.stream(names);</span><br><span class="line">        System.out.println(s5.count()); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; s6 = Stream.of(<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="斗地主GameTest："><a href="#斗地主GameTest：" class="headerlink" title="斗地主GameTest："></a>斗地主GameTest：</h3><p>主文件：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 斗地主游戏</span></span><br><span class="line">        <span class="comment">// 1.每张牌都是一个对象，定义牌类</span></span><br><span class="line">        <span class="comment">// 2.游戏房间是一个对象，定义房间类(54张牌)</span></span><br><span class="line">        <span class="type">Room</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">        r.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Card.java</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Card</span> {</span><br><span class="line">    <span class="keyword">private</span> String size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Card</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Card</span><span class="params">(String size, String color, <span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSize</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(String size)</span> {</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> {</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size + <span class="string">'\''</span> + color + <span class="string">'\''</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Room.java(房间类，实现功能，调用start（）启动)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> {</span><br><span class="line">    <span class="comment">// 1.准备54张牌，定义集合容器：存放54张牌</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Card&gt; allCards = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2.初始化54张牌，用实例代码块</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 3.准备点数</span></span><br><span class="line">        String[] sizes = {<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"10"</span>,<span class="string">"J"</span>,<span class="string">"Q"</span>,<span class="string">"K"</span>,<span class="string">"A"</span>,<span class="string">"2"</span>};</span><br><span class="line">        <span class="comment">// 4.准备花色</span></span><br><span class="line">        String[] colors = {<span class="string">"♣"</span>,<span class="string">"♦"</span>,<span class="string">"♠"</span>,<span class="string">"♥"</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 5.组合点数和花色到牌对象中区</span></span><br><span class="line">        <span class="keyword">for</span> (String size : sizes){</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">for</span>(String color: colors){</span><br><span class="line">                <span class="type">Card</span> <span class="variable">card</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(size,color,num);</span><br><span class="line">                allCards.add(card);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Collections.addAll(allCards,<span class="keyword">new</span> <span class="title class_">Card</span>(<span class="string">""</span>,<span class="string">"🃏"</span>,++num), <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="string">""</span>,<span class="string">"👲"</span>,++num) );</span><br><span class="line">        System.out.println(<span class="string">"新牌:"</span> + allCards);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 8.洗牌：随机打乱集合中的顺序</span></span><br><span class="line">        Collections.shuffle(allCards);</span><br><span class="line">        System.out.println(<span class="string">"洗牌后："</span> + allCards);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9.发牌 定义三个玩家,三个玩家都是集合容器</span></span><br><span class="line">        Map&lt;String,List&lt;Card&gt;&gt; palyers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        List&lt;Card&gt; lhc = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        palyers.put(<span class="string">"令狐冲"</span>,lhc);</span><br><span class="line">        List&lt;Card&gt; lhw = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        palyers.put(<span class="string">"令狐白"</span>,lhw);</span><br><span class="line">        List&lt;Card&gt; lhp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        palyers.put(<span class="string">"令狐紫"</span>,lhp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allCards = {洗牌后的牌}</span></span><br><span class="line">        <span class="comment">// 只发51张牌，3张作底牌，每三张三张的发做轮询</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allCards.size() - <span class="number">3</span>; i++) {</span><br><span class="line">            <span class="type">Card</span> <span class="variable">card</span> <span class="operator">=</span> allCards.get(i);</span><br><span class="line">            <span class="comment">// 求余算法为三个人发牌</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>){</span><br><span class="line">                lhc.add(card);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>){</span><br><span class="line">                lhw.add(card);</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                lhp.add(card);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.对牌排序</span></span><br><span class="line">        sortCards(lhc);</span><br><span class="line">        sortCards(lhw);</span><br><span class="line">        sortCards(lhp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三张底牌</span></span><br><span class="line">        List&lt;Card&gt; listCard = allCards.subList(allCards.size() - <span class="number">3</span>, allCards.size());</span><br><span class="line">        System.out.println(listCard);</span><br><span class="line">        <span class="comment">// 发底牌</span></span><br><span class="line">        lhp.addAll(listCard);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.看牌</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,List&lt;Card&gt;&gt; entry : palyers.entrySet()){</span><br><span class="line">            <span class="comment">// 获取玩家名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">// 获取玩家牌</span></span><br><span class="line">            List&lt;Card&gt; cards = entry.getValue();</span><br><span class="line">            <span class="comment">// 打印玩家牌</span></span><br><span class="line">            System.out.println(name + <span class="string">"的牌是："</span> + cards);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda简化代码后：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sortCards</span><span class="params">(List&lt;Card&gt; cards)</span> {</span><br><span class="line">        Collections.sort(cards, (o1,o2) -&gt; o2.getNum() - o1.getNum());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>“…”写法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>...sums)</span>{</span><br><span class="line">    System.out.println(sums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sums.length; i++) {</span><br><span class="line">        System.out.println(sums[i]);</span><br><span class="line">    }</span><br><span class="line">    System.out.println(Arrays.toString(sums));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>collections工具类（一般以s结尾）</p><p>提供常用方法：</p><table><thead><tr><th>addAll((name) , elements)</th><th>shuffle()</th><th>sort(List<t> list)</t></th><th>sort(List<t> list,comparator &lt;? super T&gt; c)</t></th></tr></thead><tbody><tr><td>批量加数组</td><td>打乱集合中元素顺序</td><td>对集合中元素进行升序排序</td><td>对list集合中元素进行批量比较器</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="I-x2F-O流（用于读写数据，文件或网络中数据）"><a href="#I-x2F-O流（用于读写数据，文件或网络中数据）" class="headerlink" title="I/O流（用于读写数据，文件或网络中数据）"></a>I/O流（用于读写数据，文件或网络中数据）</h3><p>File是 java.io 包下的类，用来代表当前操作系统的文件</p><p>注：file不能读写文件里存储的数据</p><p><code>new  File()</code>  方法创建文件夹操作</p><ul><li>mkdir()   创一个</li><li>mkdirs()  创多级文件夹</li><li>delete()  删除文件夹（只能删空文件夹）</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 掌握File创建对象代表文件（文件/目录），搞清楚其提供的对文件进行操作的方法</span></span><br><span class="line">        <span class="comment">// 1.创建File对象，获取对某个文件的信息</span></span><br><span class="line">        <span class="comment">// tip：可以反斜杠，java中两个反斜杠防止”\n“</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">""</span>);</span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line">        System.out.println(f2.isDirectory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.使用相对路径定位文件对象</span></span><br><span class="line">        <span class="comment">// 只要带盘符的都是：绝对路径 F:/development/剪辑好精品/精品图片/photo_2025-10-06_16-43-36.jpg</span></span><br><span class="line">        <span class="comment">// 相对路径是不带盘符，默认到idea工程下寻找文件，一般用来寻找工程下的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"day03-File-io\\src\\demo1File\\benson_8"</span>);</span><br><span class="line">        System.out.println(f3.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象代表不存在路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">""</span>);</span><br><span class="line">        String[] names = f4.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names){</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        }</span><br><span class="line">        File[] files = f4.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files){</span><br><span class="line">            <span class="comment">// 有一额file.delete()方法删除文件是真删，无法修复</span></span><br><span class="line">            System.out.println(file.getAbsoluteFile());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>File类遍历文件夹方法：</p><ul><li>list()   所有一级文件名到一个字符串数组中返回</li><li>listFile()   所有一级文件对象到数组中返回</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>是一种算法，在程序设计语言中广泛应用，形式上，方法调用自身方法称为递归（会造成死循环，栈内存溢出）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 计算n的阶乘</span></span><br><span class="line">        System.out.println(f(<span class="number">5</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">5</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 典型的递归算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f(n-<span class="number">1</span>) * n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算1+...n的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum(n-<span class="number">1</span>) + n;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>标准ASCII字符集（包括英语，符号等）</p><p>使用一个字节存储一个字符，首位是0，共128个字符，对美国佬够用了</p><p>中国人：GBK（汉字内码扩展规范，目标）：</p><p>​2w多个汉字等字符</p><p>​<strong>GBK中一个字符，2个字节存储</strong></p><p>​GBK兼容ASCII字符集</p><p>Unicode字符集（统一码，万国码）</p><p>​UTF-324个字节表示1字符</p><p>​UTF-8 可变长编码方案（4个长度区：1，2，3，4个字节，中文为3字节）</p><p>编码方式：</p><table><thead><tr><th>0xxxxxxx</th><th>110xxxxx 10xxxxxx</th><th>111xxxxx 10xxxxxx 10xxxxxx</th><th>1111oxxx 10xxxxx 10xxxxxx</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p>tip：英文，数字不易乱码</p><p><strong>对字符的编码解码</strong></p><p>编码(String提供)：</p><ul><li>getBytes()</li><li>getBytes(String  charsetName)  指定字符集</li></ul><p>解码：</p><ul><li>String (byte[]  bytes)</li><li>String (byte[]  bytes,String  charsetName)  指定编码解码</li></ul><p>I/O流（程序和磁盘/网络直接操作）</p><p>I指input，称为输入流，把数据读到内存中</p><p>O指Output，称为输出流，负责写数据出去</p><p><strong>流方向：</strong></p><ul><li>输入流</li><li>输出流</li></ul><p><strong>流的内容：</strong></p><ul><li>字节流<ul><li>音频</li><li>视频</li><li>图片</li></ul></li><li>字符流<ul><li>读写txt，java文件</li></ul></li></ul><p><strong>I/O流四大金刚</strong></p><ol><li>字节输入流   InputStream</li><li>字节输出流   OutputStream</li><li>字符输入流   Reader</li><li>字符输出流   Writer</li></ol><p>以上为抽象类</p><p>tip：字节流不适合做中文读写，易乱码</p><p>处理方式：</p><p>​1.定义一个与文件大小一样的字节数组，一次性读完文件的全部字节–小文件</p><p>​2.读文本适合用字符流，字节流适合做数据转移，如：文本复制（非常合适）</p><p>扩展：每次读取多个字节，性能提升，减少硬盘和内存交换次数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4fileinputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 掌握文件输入流，读写字符数据</span></span><br><span class="line">        <span class="comment">// 创建文件字节输入流管道于源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"day03-File-io\\src\\demo4fileinputStream\\shilin"</span>);</span><br><span class="line">        <span class="comment">// 针对中文，将字节流转为字符流，指定UTF-8编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件中字节并输出（垃圾）</span></span><br><span class="line"><span class="comment">//        int n;</span></span><br><span class="line"><span class="comment">//        while((n = isr.read()) != -1){</span></span><br><span class="line"><span class="comment">//            // (char) 将字节转成字符</span></span><br><span class="line"><span class="comment">//            System.out.print((char)n);</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次读写一个字符：性能差，遇到中文乱码</span></span><br><span class="line">        <span class="comment">// 使用换行ln后中文单个打出，因为UTF-8中文占3哥字节byte【3】</span></span><br><span class="line">        <span class="comment">// 定义一个桶</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 定义一个变量记住多少个字节</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>){</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>一次性读完全部字节：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4fileinputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.security.jgss.GSSUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputDemo2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"day03-File-io\\src\\demo4fileinputStream\\shiqi"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次性读完全部字节，避免汉字输出乱码问题，但是又可以内存溢出</span></span><br><span class="line">        <span class="comment">// readAllBytes（），但是文件会内存溢出问题</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = f1.readAllBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字节流转为字符串输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>字节输出流操作：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo5fileoutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fileOutputStreamDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 学会使用文件字节输出流  FileOutputStream</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"day03-File-io/src/shiqi.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">        os.write(<span class="string">'a'</span>);</span><br><span class="line">        os.write(<span class="number">98</span>);</span><br><span class="line">        os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写一个字节数组出去</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">"我爱你杨诗琦"</span>.getBytes();</span><br><span class="line">        os.write(bytes);</span><br><span class="line">        os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写一个字符数组的一部分出去</span></span><br><span class="line">        os.write(bytes,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 关闭字节流，底层上性能更好</span></span><br><span class="line">        os.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>文件字符输出流读取字符内容到程序中（多态）：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo7fileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 掌握文件字符输入流读取字符内容到程序中</span></span><br><span class="line">        <span class="comment">// 多态写法将字符流读出来</span></span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"day03-File-io\\src\\shiqi02.txt"</span>);</span><br><span class="line">                ) {</span><br><span class="line">            <span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(chs)) != -<span class="number">1</span>){</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs,<span class="number">0</span>,len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Api：<code>readAllBytes()</code>  一次性读完全部字节</p><p>​<code>.getByte()</code>  转字符数组</p><p>​<code>os.write("\r\n".getByte())</code>  //换行</p><p>byte：基本数据类型（字节数组，I/O流操作）</p><p>Byte：包装类（泛型，集合等场景）</p><h3 id="资源释放方案"><a href="#资源释放方案" class="headerlink" title="资源释放方案"></a>资源释放方案</h3><p><code>try-catch-finally</code>  ，finally必须执行一次，除非JVM终止</p><p>作用：程序执行后进行资源释放操作（专业级操作）</p><p><code>try-with-resource</code>   在try()的括号里面自动调<code>.close()</code>方法，源码继承<code>Autodoseable</code>接口</p><p>​tip：只能释放资源对象（InputStream,OutputStream）</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><code>char[] chs = new char[3];</code>  // 和字节流对象区别</p><p>Reader   管道上加上“true”在link后面，不会覆盖原内容</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo8filedemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fileWriteDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 搞清楚文件字符输出流的使用，写字符出去的流</span></span><br><span class="line">        <span class="comment">// 1.创建一个字符输出流对象，搞清楚写出去目的地</span></span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="comment">// 管道加上true就不会删原来数据</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">"day03-File-io\\src\\shiqi03.txt"</span>,<span class="literal">true</span>); <span class="comment">// 覆盖管道，把原来内容覆盖掉</span></span><br><span class="line">                ){</span><br><span class="line">            fw.write(<span class="string">"liushilin"</span>);</span><br><span class="line">            <span class="comment">// 换行符</span></span><br><span class="line">            fw.write(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">            fw.write(<span class="number">97</span>);</span><br><span class="line">            fw.write(<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写一个字符数组出去</span></span><br><span class="line">            <span class="type">char</span>[] chars = <span class="string">"java"</span>.toCharArray();</span><br><span class="line">            fw.write(chars);</span><br><span class="line">            fw.write(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写字符数组的一部分出去</span></span><br><span class="line">            fw.write(chars,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>执行顺序：</strong></p><p>编码 – 》 内存缓冲区 –I/O–》文件</p><p>（避免多次I/O操作）</p><p>​<code>.flush()</code> 刷新缓冲区</p><p>​<code>.close()</code>  关闭包含的刷新</p><p>文件复制-字节流</p><p>读文件-字符流</p><p><strong>缓冲流Buffered：</strong></p><table><thead><tr><th>InputStream</th><th>OutputStream</th></tr></thead><tbody><tr><td>FileInputStream</td><td>FileOutputStream</td></tr><tr><td>BufferedInputStream</td><td>BufferedOutputStream</td></tr></tbody></table><p>作用：提高字节输入流读取数据的性能</p><p><strong>原理：输入，输出字节8kb的缓冲池</strong></p><p>字符输入：<code>.readline()</code> 换行读文本，循环全读（按行读取，目前读取文本最优雅方案）</p><p>字符输入：<code>.newline()</code> </p><p>tip：idea快读更改多个命名方式： shift + F6</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo9bufferedInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 搞清楚缓冲字符输入流读取字符内容，性能也提升了，多了按行读文本的能力</span></span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"day03-File-io\\src\\shiqi02.txt"</span>);</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">        ) {</span><br><span class="line"><span class="comment">//            char[] chs = new char[3];</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while((len = fr.read(chs)) != -1){</span></span><br><span class="line"><span class="comment">//                String str = new String(chs,0,len);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>){</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>出师表案例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo9bufferedInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedTest1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 完成《出师表》行乱排序问题</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">""</span>));</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">""</span>));</span><br><span class="line">        ) {</span><br><span class="line">            List&lt;String&gt; list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>){</span><br><span class="line">                list.add(line);</span><br><span class="line">            }</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            System.out.println(list);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(String s  : list){</span><br><span class="line">                bw.write(s);</span><br><span class="line">                bw.newLine();</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>缓冲字节流方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">ackage demo9bufferedInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 掌握缓冲字节流的使用</span></span><br><span class="line">        <span class="comment">// 源文件：</span></span><br><span class="line">        <span class="comment">// 目标地址：(复制过去一定要带文件名，无法生成文件名)</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            copyFile(<span class="string">""</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     类型含义用途</span></span><br><span class="line"><span class="comment">     byte基本数据类型字节数组，IO 流操作</span></span><br><span class="line"><span class="comment">     Byte包装类泛型、集合等场景</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 复制文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String srcPath,String destPath)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPath);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPath);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer))  != -<span class="number">1</span>){</span><br><span class="line">                <span class="comment">// 1024  1024  3，写入到len长度</span></span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"复制成功！"</span>);</span><br><span class="line">            <span class="comment">// 关闭流，但是这种有问题</span></span><br><span class="line">            fos.close();</span><br><span class="line">            fis.close();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 经典套娃写法解决资源释放问题</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (fis != <span class="literal">null</span>) {</span><br><span class="line">                    fis.close();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) {</span><br><span class="line">                fos.close();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>性能分析（原始流/缓冲流）：</strong></p><p>测试用例：复制一个超大视频</p><p>拿系统当前时间方式：<code>System.currentTimeMillis()</code> 时间毫秒值（从1970-1-1  00:00:00开始  1s=1000ms）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo9bufferedInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.Buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTest3</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SRC_FILE</span> <span class="operator">=</span> <span class="string">"F:\\development\\omg\\2025-03-13_19-22-58.mp4"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEST_FILE</span> <span class="operator">=</span> <span class="string">"F:\\development\\剪辑好精品"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 缓冲流和原始流性能分析</span></span><br><span class="line">        <span class="comment">// 简直是个垃圾</span></span><br><span class="line"><span class="comment">//        copyFile1();</span></span><br><span class="line">        <span class="comment">// 使用低级字节流按照字节数组方式复制文件</span></span><br><span class="line">        <span class="comment">// buffered 加大，低级管道也有可能比高级管道更快</span></span><br><span class="line">        copyFile2();</span><br><span class="line">        <span class="comment">// 使用高级的缓冲字节流一个一个字节形式复制文件</span></span><br><span class="line"><span class="comment">//        copyFile3();</span></span><br><span class="line">        <span class="comment">// 使用高级的缓冲流字节数组形式复制文件</span></span><br><span class="line">        copyFile4();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用高级的缓冲流字节数组形式复制文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile4</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE));</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">"2.avi"</span>));</span><br><span class="line">        ) {</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>){</span><br><span class="line">                fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"使用高级的缓冲流字节数组形式复制文件时间是："</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用高级的缓冲字节流一个一个字节形式复制文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile3</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE));</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">"2.avi"</span>));</span><br><span class="line">        ) {</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>){</span><br><span class="line">                fos.write(len);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"使用高级的缓冲字节流一个一个字节形式复制文件时间是："</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用低级字节流按照字节数组方式复制文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile2</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">"2.avi"</span>)</span><br><span class="line">        ) {</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];  <span class="comment">// 1kb</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>){</span><br><span class="line">                fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"低级字节流按照字节数组形式复制文件时间是："</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原始流一个一个字节复制文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile1</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">"1.avi"</span>);</span><br><span class="line">        ) {</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>){</span><br><span class="line">                fos.write(len);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"低级字节流按照一个一个字节形式复制文件时间是："</span> + (end-start)/<span class="number">1000</span> + <span class="string">"s"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>结果：buffered缓冲池加大，低级管道也有可能比高级快。</strong></p><p><strong>输入输入流，结合字节数组是最优性能</strong></p><p>特：字符输入<strong>转换流</strong> <code>InputStreamReader</code>  ，解决不同编码，字符流读取文本乱码问题</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo10inputstreamreader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 不同编码读取乱码的问题</span></span><br><span class="line">        <span class="comment">// 思想：先提取文件原始字节流</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 拿到GBK的字节原始流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"day03-File-io\\src\\shiqi04.txt"</span>);</span><br><span class="line">                <span class="comment">// 使用InputStreamReader（）将GBK指定原始字节流解析</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is,<span class="string">"GBK"</span>);</span><br><span class="line">                <span class="comment">// 转为高级缓冲流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        ) {</span><br><span class="line">            String len;</span><br><span class="line">            <span class="keyword">while</span>((len = br.readLine()) != <span class="literal">null</span>){</span><br><span class="line">                System.out.println(len);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>printStream/printWrite  (字节/字符)</p><p><strong>特殊数据流：</strong> <code>DataInputStream</code> <code>DataOutputStream</code>   (允许数据类型一并写出)</p><p>I/O框架（Framework）  </p><p><strong>用的“<a href="https://commons.apache.org/io/download_io.cgi%E2%80%9D">https://commons.apache.org/io/download_io.cgi”</a>  Apache的commons  IO的jar包</strong></p><p><strong>用法：</strong>导入commons-io-2.11.0.jar，项目中新建” .lib “库文件，在jar包文件右键，”Add  ad  Library”(在类包中使用，否则无法导入)</p><p><strong>打印流使用：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> printstream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printStreamDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 打印流使用</span></span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">"day03-File-io/src/ps.txt"</span>);</span><br><span class="line">                ){</span><br><span class="line">            ps.println(<span class="number">97</span>);</span><br><span class="line">            ps.println(<span class="string">'a'</span>);</span><br><span class="line">            ps.println(<span class="string">"你是个傻逼"</span>);</span><br><span class="line">            ps.println(<span class="literal">true</span>);</span><br><span class="line">            ps.println(<span class="number">99.9</span>);</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>特殊数据流</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> printstream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dataStreamDemo2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 特殊数据流</span></span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"day03-File-io/src/data.txt"</span>));</span><br><span class="line">                ){</span><br><span class="line">                <span class="comment">// 写出的文件不是乱码，是带了类型的</span></span><br><span class="line">                dos.writeByte(<span class="string">'a'</span>);</span><br><span class="line">                dos.writeUTF(<span class="string">"nihao"</span>);</span><br><span class="line">                dos.writeInt(<span class="number">97</span>);</span><br><span class="line">                dos.writeDouble(<span class="number">99.9</span>);</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="多线程（思想-gt-代码）Thread"><a href="#多线程（思想-gt-代码）Thread" class="headerlink" title="多线程（思想>代码）Thread"></a>多线程（思想&gt;代码）Thread</h3><p><strong>创建方式1：</strong></p><ol><li>定义一个子类<code>MyThread</code> 类继承 java.lang.Thread，重写<code>run()</code> 方法</li><li>创建 <code>Mythread</code> 类对象</li><li>调用线程的<code>start()</code>对象启动线程（启动后执行run()）</li></ol><p>缺点：单继承</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1create;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1create</span> {</span><br><span class="line">    <span class="comment">// main方法本身是有一条主线程负责执行的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 认识多线程，掌握创建线程的方式一,继承thread类实现</span></span><br><span class="line">        <span class="comment">// 4.创建线程类对象，代表线程</span></span><br><span class="line">        <span class="type">MyTread</span> <span class="variable">myTread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTread</span>();</span><br><span class="line">        <span class="comment">// 5.调用start方法，启动线程</span></span><br><span class="line">        myTread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"主线程输出："</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">    <span class="comment">// 2. 重写Thread的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 3.在run方法中编写线程的任务代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"子线程已经启动："</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>创建方式2</strong></p><ol><li>定义线程任务类<code>MyRunnable</code>实现接口<code>Runnable</code>接口，重写<code>run()</code>方法</li><li>创建<code>MyRunnable</code>对象</li><li>把<code>MyRunnable</code> 任务对象交给Thread线程对象处理</li><li>调<code>start()</code>启动</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1create;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 掌握多线程的创建方式二：实现Runnable接口来创建</span></span><br><span class="line">        <span class="comment">// 3.创建线程任务类代表一个线程</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 4.把线程任务对象交给一个线程对象来处理</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        <span class="comment">// 5.启动线程任务对象</span></span><br><span class="line">        r.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"主线程执行开跑："</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个线程任务类来实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>{</span><br><span class="line">    <span class="comment">// 2.重写run方法设置线程</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"子线程启动："</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>创建方式3</strong></p><p><strong>可以返回线程执行完毕后的结果</strong></p><p><strong>利用Callable接口，FutureTask类来实现</strong></p><ol><li>定个类实现<code>Callable</code>接口，重写call方法，封装要做的事，返回数据</li><li>把<code>Callable</code>类型对象封装成<code>FutureTask</code>（线程任务对象）</li><li>调Thread对象的start()方法启动线程</li><li>调用<code>FutureTack</code>的<code>get</code>方法获返回结果</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1create;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建线程的第三种方式</span></span><br><span class="line">        <span class="comment">// 实现Callable接口，优势，获得线程执行完毕后的返回值</span></span><br><span class="line">        <span class="comment">// 3.创建Callable接口的实现对象</span></span><br><span class="line">        Callable&lt;String&gt; mc = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 4.包装成FutureTask线程任务对象</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 未来对象作用</span></span><br><span class="line"><span class="comment">         * 本质是一个Runnable线程任务对象，可以交给Thread线程对象处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 5.调用Tread方法的start方法启动线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        tr.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2：</span></span><br><span class="line">        Callable&lt;String&gt; mt = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">50</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mt);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f1);</span><br><span class="line">        tr2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.调用FutureTask里的get方法获取返回值</span></span><br><span class="line">        <span class="comment">// 这里get方法异常，建议分开try  catch(不同线程异常之间不容易混杂)</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 如果主线程发现第一个线程还没执行完毕，会让出cpu，等第一个线程执行完毕后，才会往下执行</span></span><br><span class="line">            System.out.println(ft.get());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 如果主线程发现第二个线程还没执行完毕，会让出cpu，等第一个线程执行完毕后，才会往下执行</span></span><br><span class="line">            System.out.println(f1.get());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个实现类实现Callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;{</span><br><span class="line">    <span class="comment">// 有参构造器接受传参</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 实现call方法，定义线程执行体</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) {</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum += i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"子线程返回的结果"</span> + n + <span class="string">"的和是："</span> + sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>获取线程名字：</strong>Thread-索引（默认）</p><p>方法：</p><ul><li>getName()  方法</li><li>currentThread()  Thread方法获主线程</li><li>setName()  设置线程名</li><li>join()  线程插队</li></ul><p><strong>线程睡眠（sleep()，百度网盘不冲会员限速类似）</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2threadapi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadApiDemo2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 线程休眠sleep（）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="comment">// 这一行代码几万块</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>join()方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2threadapi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadApiDemo3</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 搞清楚线程的join方法  调用这个方法的线程先执行（线程插队）</span></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(<span class="string">"小琦"</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"线程输出："</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    t.join();  <span class="comment">// 线程插队</span></span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">MyThread2</span><span class="params">(String name)</span>{</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"子线程输出是："</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>多个线程，同时操作同一个共享资源时，业务安全问题（银行取钱问题）</p><p><strong>解决方案：</strong></p><p>线程同步，让多个线程先后依次访问共享资源（加锁，每次只允许一个线程加锁）</p><p><em>模拟线程安全</em></p><p>threadDemo1.java:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3threadsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threadDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 模拟线程安全问题</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">"ICBC-01"</span>,<span class="number">100000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(<span class="string">"小刘"</span>,acc).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(<span class="string">"小杨"</span>,acc).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>DrawThread.java:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3threadsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(String name,Account acc)</span> {</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Account.java:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3threadsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> {</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span>{}</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> {</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span>{</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money){</span><br><span class="line">            System.out.println(name + <span class="string">"取钱成功，吐出了："</span> + <span class="built_in">this</span>.money + <span class="string">"元"</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">"取钱成功，余额剩下："</span> + <span class="built_in">this</span>.money + <span class="string">"CNY"</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            System.out.println(name + <span class="string">"取钱失败，余额不足"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>方式一（同步代码块）：</strong></p><p>原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可执行</p><p>使用：synchronized(同步锁){  访问核心代码块  } （锁对象）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整Account文件里的这个部分，用"this"作为锁对象</span></span><br><span class="line"><span class="comment">// 用this账户作为他们的锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span>{</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money){</span><br><span class="line">                System.out.println(name + <span class="string">"取钱成功，吐出了："</span> + <span class="built_in">this</span>.money + <span class="string">"元"</span>);</span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">"取钱成功，余额剩下："</span> + <span class="built_in">this</span>.money + <span class="string">"CNY"</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                System.out.println(name + <span class="string">"取钱失败，余额不足"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>锁的选择：</strong>无static称实例方法。锁对象不能随便选择唯一对象，建议使用共享资源作为锁对象，<strong>实例方法用this作锁对象。对静态资源建议用字节码（类名.class） 对象作为锁对象</strong></p><hr><p><strong>方式二同步方法：</strong></p><p>把核心方法（共享的）上锁，<strong>修饰符  <code>synchronized</code>   返回值类型   方法名称（形参列表）{  操作共享资源代码  }</strong></p><p><strong>Lock锁</strong></p><p><code>private final lock lk = new ReentrantLock();</code> // final 防止撬锁</p><p>lk.lock()  上锁</p><p>lk.unlock()  解锁，放try - Finally 这里解锁，防异常</p><p>区别部分操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span>{</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        lk.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money){</span><br><span class="line">                System.out.println(name + <span class="string">"取钱成功，吐出了："</span> + <span class="built_in">this</span>.money + <span class="string">"元"</span>);</span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">"取钱成功，余额剩下："</span> + <span class="built_in">this</span>.money + <span class="string">"CNY"</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                System.out.println(name + <span class="string">"取钱失败，余额不足"</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lk.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>任务对象：workQueue</p><p>工作线程：workThread</p><p>任务接口：Runnable/Callable</p><p>思想：线程复用</p><p>方式1：</p><p>​JDK5.0起提供了线程池接口：<code>ExecutorService</code> ,实现类 <code>ThreadPoolExecutor</code></p><p>方式2：</p><p>​使用<code>Executor</code>线程池工具类，调用方法返回不同特点的线程池对象</p><p>一·，通过ThreadPoolExecutor创线程池对象</p><ol><li>参数1，corePoolSize：指定线程池核心线程数   （正式工：2）</li><li>maximumPoolSize：指定池最大线程数   （最大员工：5，临时工：2）</li><li>keepAliveTime：指定临时线程存活时间   （临时工空闲多久被开除）</li><li>unit：指定线程存活时间单位（秒，分，时，天）  </li><li>workQueue：指定线程池任务队列    （客人排队的地方）</li><li>threadFactory：指定线程工厂      （负责招聘员工的 ）</li><li>handler：指定线程池任务拒绝策略      （忙不过来咋办）</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java高级</title>
      <link href="/2025/11/15/java%E9%AB%98%E7%BA%A7/"/>
      <url>/2025/11/15/java%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="java面向对象高级"><a href="#java面向对象高级" class="headerlink" title="java面向对象高级"></a>java面向对象高级</h3><p>（代码块，内部类，函数时编程，常用API，gui编程/不重要）</p><p><strong>代码块是类的5大组成部分：成员变量，构造器，方法，代码块，内部类</strong></p><p><em>API：Arrays,toString(数组名)   //返回数组内容</em></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行顺序（静态代码块 static{}）</span></span><br><span class="line"><span class="comment">* class -&gt; static(对静态资源初始化) —&gt; main（优先执行）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h3><p>1.内部类可以直接访问外部类的</p><ul><li>静态成员（static修饰）</li><li>实例成员（无static）</li></ul><p>2.外部类名 .this 可以拿到寄生的外部类对象<code>外部类名.this</code></p><p>静态内部类属于外部类本身（内部类有static修饰）</p><p><code>Outer.Inner oi = new Outer.Inner();</code></p><h3 id="匿名内部类（不用为类声明名字，默认隐藏名字）"><a href="#匿名内部类（不用为类声明名字，默认隐藏名字）" class="headerlink" title="匿名内部类（不用为类声明名字，默认隐藏名字）"></a><strong>匿名内部类（不用为类声明名字，默认隐藏名字）</strong></h3><p>本质是子类，同时会立即创建一个子类对象  -&gt; 外部类名$ 编号</p><p>用法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(){</span><br><span class="line">    重写方法  <span class="comment">// 立即重写抽象父类方法</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//中段简写：</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">click</span> implements (name)</span><br><span class="line"> click(<span class="keyword">new</span> (name)(){</span><br><span class="line">重写方法</span><br><span class="line"> })</span><br></pre></td></tr></tbody></table></figure><p>API： Arrays.sort() // 排序</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a><strong>函数式编程</strong></h3><p>Java中函数概念是：Lambda表达式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Swim</span> <span class="variable">s2</span> <span class="operator">=</span> ()-&gt;{</span><br><span class="line">    sout;</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 只能替代函数式接口的内部类，注解： @FuntionalInterface</span></span><br></pre></td></tr></tbody></table></figure><p>Lambda省略规则：</p><ol><li>括号里参数类型全部可以省略</li><li>只有一个参数，参数的{}也可以省略，多个参数不行</li><li>Lambda中只有一行表达式，“{}”不写，“；”省略，有return去掉</li></ol><p>构造器引用：</p><p>​类名::new</p><p><strong>String常用API：</strong></p><p>java.lang 包/自动导的包</p><p>tip: 每次new都会产生一个新对象，在堆内存中</p><p>方式1：（推荐）直接调“ ”创建字符串，封装字符串对象</p><p>方式2：构造器初始化对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">" "</span>);</span><br><span class="line"><span class="type">char</span>[] chars = {<span class="string">'n'</span>,<span class="string">'e'</span>,<span class="string">''</span>,<span class="string">''</span>};</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars); <span class="comment">// 将chars字符转字符串</span></span><br></pre></td></tr></tbody></table></figure><p>提供的方法：</p><ul><li>length()  获取字符串长度</li><li>charAt() 获取索引位置字符返回</li><li>toChatArray() 字符串转字符数组返回</li><li>equals()  判断两个字符串是否一样</li><li>equalsIgonreCase()  忽略大小判断两个字符串是否一样</li><li>substring()  从传入索引处截取到末尾获取新字符串，可以两参/一参</li><li>replace()  用新值替换旧值</li><li>contains()  判断字符串是否包含某个字符</li><li>startsWith()  判断字符串是否有以….开头</li><li>split()  以某个字符分割，并返回字符串</li></ul><h3 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a><strong>ArrayList集合</strong></h3><p>创建：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arraylist &lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">Arraylist</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提供add()  remove()  set()  get()  size()方法</span></span><br><span class="line"><span class="comment">* &lt;E&gt;  泛型（后续提到）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>此处略过Gui图形化界面编程…….</p><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2025/11/14/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/11/14/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="day01："><a href="#day01：" class="headerlink" title="day01："></a>day01：</h3><h6 id="idea文件结构-x2F-基础数据类型："><a href="#idea文件结构-x2F-基础数据类型：" class="headerlink" title="idea文件结构/基础数据类型："></a>idea文件结构/基础数据类型：</h6><ul><li><p>工程文件：project-&gt;Model-&gt;packet-&gt;class</p></li><li><p>创建方式: new 一个Emply Project -&gt; 新建Model -&gt; new packet</p></li><li><p>out文件里是javac编译好的.class 文件</p></li><li><p>idea集成ai插件：阿里/通灵码</p><table><thead><tr><th align="left">整形</th><th>浮点型</th><th>字符型</th><th>布尔型</th></tr></thead><tbody><tr><td align="left">byte/short/int/long</td><td>float/double</td><td>char</td><td>boolean</td></tr><tr><td align="left">1/2/4/8</td><td>4byte/8byte</td><td>2byte</td><td>1byte</td></tr><tr><td align="left"></td><td></td><td></td><td></td></tr></tbody></table></li></ul><h3 id="day02"><a href="#day02" class="headerlink" title="day02:"></a>day02:</h3><p>java开发中，<strong>功能的最小单位</strong>是：<strong>方法（函数class）</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名（）{}</span><br><span class="line"><span class="comment">// void 无返回值类型，调用方法时无法用变量接</span></span><br></pre></td></tr></tbody></table></figure><p><strong>方法重载：</strong> 一个类中，多个方法名相同，但形参列表不同，称为方法重载（类型不同，顺序不同，个数不同）</p><h6 id="自动类型-x2F-强制类型转换："><a href="#自动类型-x2F-强制类型转换：" class="headerlink" title="自动类型/强制类型转换："></a><strong>自动类型/强制类型转换：</strong></h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">(<span class="type">byte</span>)i;</span><br><span class="line"><span class="comment">// 强制转换数据类型，装不下会数据溢出</span></span><br></pre></td></tr></tbody></table></figure><h6 id="Scanner（）方法："><a href="#Scanner（）方法：" class="headerlink" title="Scanner（）方法："></a><strong>Scanner（）方法：</strong></h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.io);</span><br><span class="line"><span class="type">int</span> <span class="variable">name</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">// 调用Scanner方法获取用户输入</span></span><br></pre></td></tr></tbody></table></figure><h6 id="分支语句："><a href="#分支语句：" class="headerlink" title="分支语句："></a>分支语句：</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>() <span class="comment">// if...else if判断语句</span></span><br><span class="line"><span class="keyword">switch</span>() <span class="comment">// switch...case 1: 选择语句</span></span><br></pre></td></tr></tbody></table></figure><h6 id="循环结构："><a href="#循环结构：" class="headerlink" title="循环结构："></a>循环结构：</h6><p>作用：减少重复代码</p><p>for：知道循环次数</p><p>while：不知道循环次数</p><p>do…while：先do再while判断</p><p>print：不换行打印</p><p>println：换行打印</p><p><strong>循环嵌套：</strong> <em><strong>外部循环执行一次，内部循环整体会完整执行一轮</strong></em> </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++){</span><br><span class="line">    sum += i;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// for循环语句，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(sum == <span class="number">0</span>){</span><br><span class="line">    <span class="comment">// 判断完执行循环体，写死循环好用</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">do</span>{</span><br><span class="line">  <span class="comment">// 业务很少使用  </span></span><br><span class="line">}<span class="keyword">while</span>（）</span><br></pre></td></tr></tbody></table></figure><h3 id="day03："><a href="#day03：" class="headerlink" title="day03："></a>day03：</h3><h6 id="猜数字程序："><a href="#猜数字程序：" class="headerlink" title="猜数字程序："></a>猜数字程序：</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Randow()方法生成随机数</span></span><br><span class="line"><span class="comment">// Math.randow() 方法(java内置，返回[0,1]随机小数)</span></span><br><span class="line"><span class="comment">// 例：(Math.randow() * 100) + 1</span></span><br><span class="line"><span class="type">Randow</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Randow</span>();</span><br><span class="line">r.nextInt(<span class="number">100</span>); <span class="comment">// 随机生成[0,99]的随机数</span></span><br><span class="line">Math.sqrt(); <span class="comment">// 一个数的开平方</span></span><br><span class="line">isprime（）; <span class="comment">// 判断是否为1或0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的创建 （二维数组在此基础上加）</span></span><br><span class="line"><span class="comment">// 底层还是new创建对象</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]{};</span><br><span class="line"><span class="comment">// 日常写法：</span></span><br><span class="line"><span class="type">int</span> arr[] = {};</span><br></pre></td></tr></tbody></table></figure><h3 id="面向对象编程（万物皆对象）："><a href="#面向对象编程（万物皆对象）：" class="headerlink" title="面向对象编程（万物皆对象）："></a>面向对象编程（万物皆对象）：</h3><p>[class  类] 自己定义模板</p><p>封装的class里可以写功能： </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名(){}</span><br><span class="line"><span class="comment">// 采用.方法名 调用方式</span></span><br></pre></td></tr></tbody></table></figure><p><strong>每new一次都在JVM内存中，main方法归属于栈内存，定义变量再堆内存</strong></p><h6 id="类的基本语法（IDEA中右键生成）："><a href="#类的基本语法（IDEA中右键生成）：" class="headerlink" title="类的基本语法（IDEA中右键生成）："></a><strong>类的基本语法（IDEA中右键生成）：</strong></h6><ul><li>构造器（有参构造器/无参构造器，类名必须和方法名一样）</li><li>this （指代方法作用范围内的变量，哪个对象调用这个方法，this就拿到这个对象，解决变量名冲突问题）</li><li>封装</li><li>Javabean</li><li>static</li></ul><h6 id="oob3大特征："><a href="#oob3大特征：" class="headerlink" title="oob3大特征："></a>oob3大特征：</h6><ul><li><h6 id="封装-（类，方法都是一种封装思想：合理隐藏，合理暴露）"><a href="#封装-（类，方法都是一种封装思想：合理隐藏，合理暴露）" class="headerlink" title="封装  （类，方法都是一种封装思想：合理隐藏，合理暴露）"></a>封装  （类，方法都是一种封装思想：<u>合理隐藏，合理暴露</u>）</h6></li><li><p><strong>继承</strong> </p></li><li><p>**多态 **</p></li></ul><p><em>使用 <code>private</code> 关键字修饰的成员变量，就只能在本类中直接访问</em></p><p><strong>class类中定义方法：get()  /  set()方法对象公开操作</strong></p><p>java规范：</p><ol><li>公开成员，用 <code>public</code> 公开</li><li>私有成员，用 <code>private</code> 私有</li></ol><p><strong>javabean（特殊类，实体类）：</strong></p><p>业务功能（对实体类操作定义在这一类上）</p><p>static：静态，修饰成员变量，成员方法（类变量，只加载一份，被类和类的全部对象共享访问）属于类</p><p>无static修饰(实例变量)    属于对象，每个对象都有一份</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>(){}</span><br><span class="line"><span class="comment">// 类名.  访问静态变量（Student.name）</span></span><br><span class="line"><span class="comment">// 对象名   student sc = new student();  sc.name;</span></span><br></pre></td></tr></tbody></table></figure><p>规范：</p><ol><li>方法只是为了做一个功能且不需要直接访问对象数据，定义静态方法</li><li>方法只是对象行为，要访问对象数据，定义实例方法</li></ol><p>用途：定义工具类，可以用类名直接”.”访问</p><p>（私有对象，没必要new出来，里加  private  类名 () {}   ）</p><h6 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>{}</span><br></pre></td></tr></tbody></table></figure><p>子类继承父类的非私有成员（成员变量，成员方法）</p><h6 id="四种权限修饰符："><a href="#四种权限修饰符：" class="headerlink" title="四种权限修饰符："></a>四种权限修饰符：</h6><table><thead><tr><th>private</th><th>缺省</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>只能本类</td><td>本类，同一个包的类</td><td>本类，同一个包，子孙类中</td><td>任意位置</td></tr></tbody></table><p><strong>特点：</strong></p><ol><li>单继承</li><li>java中的类不支持多继承（不能多个父）</li><li>支持多层继承（父，爷.）</li><li>祖宗类：Object，默认继承</li></ol><p>if 子父类同一（重名）成员变量，访问父类的变量，用super()。</p><p><strong>方法重写：</strong></p><p>继承父类的方法，一个方法名，参数列表一样的方法去覆盖</p><p>方法名（参数形参）  和父一致，重写内容。      头加+注解：<code>@Override</code>（标志注解：优雅，安全）</p><p>子类constructor，都会先调用父类的construtor 再调用自己的constructor.</p><p>this（…） 调兄弟构造器，super（…）必须写在构造器第一行，</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li><p>对象多态</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译看左边，运行看右边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>{} <span class="comment">// </span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">wolf</span>();  <span class="comment">// (子)</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tortoise</span>; <span class="comment">// （子）extends继承关系</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>行为多态</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过重写run（）方法。tip：变量不谈多态</span></span><br><span class="line">s1.run();</span><br><span class="line">s2.run();</span><br></pre></td></tr></tbody></table></figure></li></ul><p>条件：</p><ol><li>有继承/实现关系</li><li>存在父类引用子类对象关系 <code>Animal a1 = new wolf();</code></li><li>存在重写方法（必须）—行为多态</li><li>多态下不能调用子类独有功能</li></ol><p>用法：</p><p><code>new</code>  （多态） 后续用到I/O流，Stream流，列表等都会多态写法</p><p>类型转换：解决多态下不能调独有功能情况</p><p>​自动。父类变量名=new 子类（）；</p><p>​强制。子类变量名= （子类）父类变量；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ide中的注解，用于生成getter，setter，无参构造器，toString（）方法</span></span><br><span class="line"><span class="comment">// 必须要导包，不用的话手动生成</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">// 自动生成有参构造器</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span><span class="comment">// 自动生成无参构造器</span></span><br></pre></td></tr></tbody></table></figure><h4 id="面向对象的高级（final，单例类，枚举类，抽象类，接口）"><a href="#面向对象的高级（final，单例类，枚举类，抽象类，接口）" class="headerlink" title="面向对象的高级（final，单例类，枚举类，抽象类，接口）"></a>面向对象的高级（final，单例类，枚举类，抽象类，接口）</h4><p><strong>final：</strong></p><table><thead><tr><th>修饰类</th><th>修饰方法</th><th>修饰变量</th></tr></thead><tbody><tr><td>为最终类，不能被继承</td><td>为最终方法，不能被重写</td><td>为最终变量，该变量只能被赋值一次</td></tr></tbody></table><p><strong>变量（tip：常量全大写，用”_”连接）：</strong></p><table><thead><tr><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>静态成员变量（final修饰静态成员变量，称为常量）<br>实例成员变量</td><td>for循环体中的这类</td></tr></tbody></table><p>静态：<code>public static final String SCHOOL_NAME = "";</code></p><p>实例：<code>public final String name = "" // 没意义</code></p><p><strong>单例类（软件设计模式，架构师级）</strong></p><p>设计模式：n种解法种最优解，此最优解被总结出来，称为设计模式</p><p>“单例设计模式”（类似任务管理器，只能开一个）</p><p>作用：确保某个类只能创建一个对象</p><ul><li>饿汉单例：<ol><li>私有化构造器，<code>private  类名 （）{}</code></li><li>定私有化类变量，记住一个类的一个对象，<code>private static (class name) a = new  (class name);</code></li><li>定义一个公开方法返回类变量，<code>public static  (name) (){return  a;}</code></li></ol></li><li>懒汉单例：<ol><li>私有化构造器</li><li>定义静态私有化类变量，不new “b”</li><li>定义公开的类方法判断  <code> b == null,b = new B();</code> ，并返回b（类 method）</li></ol></li></ul><p><strong>枚举类（public enum A(){}）：</strong></p><p>tip: javap可以反编译java文件</p><ul><li>.name()拿对象名 </li><li>.ordinal()      拿对象索引</li></ul><p>枚举类  extends  java.lang.Enum<a>   // 所以不能继承其他；</a></p><p>​</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">enum</span>  <span class="title class_">A</span>（）{</span><br><span class="line"></span><br><span class="line">x； <span class="comment">// 也是个单例对象</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>应用场景：信息分类和信息标志</p><p><strong>抽象类：</strong></p><p>Java关键字 Abstract,修饰类，成员方法</p><p>作用：就是被子类继承</p><p>使用方法：子类继承父类时，父类只写 <code>public abstract void  (name)();</code>  (便于重写父类代码)</p><p><strong>模板方法设计模式（解决代码重复问题）：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">name</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>{</span><br><span class="line">        sout;</span><br><span class="line">        sout;</span><br><span class="line">        writeMain();</span><br><span class="line">        sout;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">writeMain</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 模板方法调用抽象类方法（Tip：最好用final修饰，不能被重写）</span></span><br></pre></td></tr></tbody></table></figure><p><strong>接口（interface）：</strong></p><p>用处：</p><ol><li><p>弥补类单继承问题（继承多个）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Driver</span>{}</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BoyFriend</span>{}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>{}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">extends</span> <span class="title class_">People</span> implement Driver,BoyFriend{}</span><br></pre></td></tr></tbody></table></figure></li><li><p>可实现面向接口编程，更利于解耦合</p></li></ol><p>接口被类实现（implement）的，称：实现类。一个类可以实现多个接口</p><p>注意：必须实现接口的所有抽象方法（或定义为抽象类）</p><p><em>JDK8后新增：</em></p><p><code>default void test1(){} //实例方法，实现类new出调</code></p><p><code>private void test2(){} // 私有方法，接口中调</code></p><p><code>static void test3(){} // 静态方法，接口名调用</code></p><p><strong>接口注意事项：</strong></p><ol><li><p>接口与接口可以多继承 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span><span class="keyword">interface</span> <span class="title class_">B</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span><span class="keyword">extends</span> <span class="title class_">A</span>,B</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>一个接口中继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承，也不支持多实现</p></li><li><p>一个类继承父类，又同时实现接口，如果父类中和接口同名的方法，实现类优先用父类的</p></li><li><p>一个类实现多个接口，如果多个接口存在同名的默认方法，可以不冲突，这个类重写该方法即可</p></li></ol><p><strong>抽象类，接口对比</strong></p><p>相同：</p><ul><li>都是抽象形式，可抽象方法，不能创建对象</li><li>都是派生子类形式，抽象类被子类继承使用，接口被实现类</li><li>类继承子类或接口，都要重写抽象方法</li><li>都支持多态，实现解耦合</li></ul><p>不同：</p><ul><li>抽象类定义全部成员变量，接口定义常量</li><li>单继承</li><li>接口更适合做解耦合，更灵活</li><li>抽象类体现模板思想，更适合做父类继承</li></ul><p>tip：boolean值不是get method，是is</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>产品经理入门</title>
      <link href="/2025/11/10/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%85%A5%E9%97%A8/"/>
      <url>/2025/11/10/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="产品经理"><a href="#产品经理" class="headerlink" title="产品经理"></a>产品经理</h2><ul><li>产出：1份立项的文档，一份产品结构图，一套项目原型</li></ul><p><strong>想清楚产品怎么做的人</strong></p><p>合格产品包括啊：</p><ol><li><strong>用户，场景，需求</strong></li><li><strong>功能，体验/优势，价值</strong></li></ol><h2 id="产品经理分类"><a href="#产品经理分类" class="headerlink" title="产品经理分类"></a>产品经理分类</h2><table><thead><tr><th>产品</th><th>公司</th></tr></thead><tbody><tr><td>服务对象</td><td>行业/职级</td></tr><tr><td>平台</td><td>工作内容</td></tr></tbody></table><h3 id="面向服务对象区分"><a href="#面向服务对象区分" class="headerlink" title="面向服务对象区分"></a><strong>面向服务对象区分</strong></h3><table><thead><tr><th>C端产品经理</th><th>B端产品经理</th><th>G端产品经理</th></tr></thead><tbody><tr><td>面向普通用户</td><td>面向公司内部系统或外部企业</td><td>面向政府部门，政务服务公共类产品</td></tr><tr><td>如：淘宝，微信</td><td>如：OA，CRM或者SaaS类产品</td><td>如：政务服务网站，公安系统，户政系统</td></tr></tbody></table><h3 id="按产品不同区分"><a href="#按产品不同区分" class="headerlink" title="按产品不同区分"></a><strong>按产品不同区分</strong></h3><table><thead><tr><th>移动端产品经理</th><th>PC客户端产品经理</th><th>Web端产品经理</th><th>智能硬件产品经理</th></tr></thead><tbody><tr><td>手机应用程序，H5页面</td><td>手机桌面引用程序</td><td>网页相关前后台</td><td>软件硬件结合家居，医疗，汽车，穿戴设备</td></tr></tbody></table><h3 id="公司所属行业不同"><a href="#公司所属行业不同" class="headerlink" title="公司所属行业不同"></a><strong>公司所属行业不同</strong></h3><table><thead><tr><th>教育产品经理</th><th>电商产品经理</th><th>金融产品经理</th><th>医疗产品经理</th><th>社交产品经理</th></tr></thead><tbody><tr><td>xx教育</td><td>淘宝，京东</td><td>支付宝，财付通</td><td>春雨医生，健康160</td><td>微信，QQ</td></tr></tbody></table><h3 id="按工作内容划分"><a href="#按工作内容划分" class="headerlink" title="按工作内容划分"></a><strong>按工作内容划分</strong></h3><table><thead><tr><th>功能产品经理</th><th>策划产品经理</th><th>商业产品经理</th><th>数据产品经理</th><th>用户体验产品经理</th></tr></thead><tbody><tr><td>专注产品功能规划设计，基于用户需求和业务改进点设计页面功能</td><td>专注设计策划方案，如根据用户生命周期，设计用户增长策略，根据用户画像推进策略等</td><td>参与商业化运营决策，商业变现模式设计，对收入利润和ROI负责，营收场景设计，广告变现等</td><td>专注设计数据中台和大数据中台相关数据产品解决方案，研究数据价值，数据驱动决策</td><td>专注用户体验设计，理解用户心理，关注交互，UI等交互体验和视觉效果</td></tr></tbody></table><ul><li>职级划分</li></ul><ol><li>产品专员/助理（原型设计，文档撰写）</li><li>产品经理（对自己负责的模块有话语权和决策权）</li><li>高级产品经理（负责某个产品线或业务线）</li><li>产品总监（多个产品线或业务线负责人）</li></ol><h2 id="产品开发流程"><a href="#产品开发流程" class="headerlink" title="产品开发流程"></a>产品开发流程</h2><table><thead><tr><th>分析定义</th><th>软件设计</th><th>编码测试</th><th>运行维护</th></tr></thead><tbody><tr><td>问题定义</td><td>概要设计</td><td>程序编码</td><td>运行维护</td></tr><tr><td>可行性研究</td><td>详细设计</td><td>集成测试</td><td></td></tr><tr><td>需求分析</td><td></td><td></td><td></td></tr></tbody></table><ul><li><p><strong>产品技术中心</strong></p><ol><li>产品设计部</li></ol><ul><li><em>产品经理</em><br>  <em>平面设计师</em><br>  <em>交互设计师</em></li></ul><ol start="2"><li>研发部</li></ol><ul><li><em>前端工程师</em><br>  <em>后端工程师</em><br>  <em>运维工程师</em><br>  <em>测试工程师</em></li></ul><ol start="3"><li>项目组</li></ol><ul><li><em>项目经理</em>（不一定每个公司有）</li></ul></li></ul><h3 id="前端工程师"><a href="#前端工程师" class="headerlink" title="前端工程师"></a>前端工程师</h3><pre><code> 网站，app，小程序</code></pre><h3 id="后端工程师"><a href="#后端工程师" class="headerlink" title="后端工程师"></a>后端工程师</h3><pre><code>平台设计，接口设计，功能实现</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>正确，完整，安全，质量保证</code></pre><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><pre><code>服务器，操作系统，数据库</code></pre><h3 id="项目经理职责"><a href="#项目经理职责" class="headerlink" title="项目经理职责"></a>项目经理职责</h3><pre><code>制定项目管理计划组建项目团队跟踪项目进度监控项目质量控制项目成本</code></pre><h3 id="产品经理职责"><a href="#产品经理职责" class="headerlink" title="产品经理职责"></a>产品经理职责</h3><pre><code>评估产品机会    1. 需求收集    2. 可行性研究 ---&gt; MRD（市场需求文档）/立项报告定义要开发产品    1. 需求分析    2. 原型设计</code></pre><h3 id="用户体验设计师"><a href="#用户体验设计师" class="headerlink" title="用户体验设计师"></a>用户体验设计师</h3><pre><code>用户界面设计/UI    1. 视觉效果    2. 界面图标 ---&gt; 效果图/icon用户交互设计/UE    1. 动作交互    2. 反馈体验 ---&gt; 交互稿</code></pre><ul><li>工作误区<br>  画原型的<br>  管理项目的（关注产品本身）<br>  需求混淆（老板用户自己需求不等于产品需求）<br>  职权混淆（对产品生命周期负责，驱动同事写作，属同级）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>6年后我们在一起了</title>
      <link href="/2025/11/07/6%E5%B9%B4%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86/6%E5%B9%B4%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86/"/>
      <url>/2025/11/07/6%E5%B9%B4%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86/6%E5%B9%B4%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h2 id="幸福（2025-10-21-10-26）-杨诗琦"><a href="#幸福（2025-10-21-10-26）-杨诗琦" class="headerlink" title="幸福（2025.10.21-10.26）_ 杨诗琦"></a>幸福（2025.10.21-10.26）_ 杨诗琦</h2><p>白云机场落地见到你的一刻，恍惚这 6 年的时间。我们曾经无数个日夜的牵绊，也经历不少的吵闹，都是 17，19 的繁华记忆<br>这些年不曾敢打扰，也经历了各自的生活，感谢源于 24 岁的杨诗琦勇敢的走出这一步<br>6 年化为这 6 天时光，很开心也很幸福，我们牵着手走在广州的街头。体育西，天河城，维多利广场，沙面，永庆坊，祖庙，西华路，万胜围。一起拍了人生中第一张红底合照，一起搭上驶向广州塔的有轨电车，品尝了各式各样的“清汤寡水”，但都因为和你一起，真的让人迷醉在幸福里<br>5 个晚上的沟通，促进了你我，你告诉我你爱我的决心，也告诉我想和我结婚，没有任何退路。而刘仕林是真的真的想给你个未来，也会为之努力！</p><img src="https://bensonFuck.github.io//images/微信图片_20251027212732_51_165.jpg" alt="第一张我们" style="zoom:5%;"><p>2025/11/19</p><p>相处了有一个月</p><p>曾一直纠结杨诗琦为什么喜欢我这个问题，也得到了你给我的清晰回答，是生理性喜欢，是一种无法清晰说出来具体喜欢哪个点的喜欢，就是从一开始认识见面的那一刻起，就感觉磁场合。这个回答让我感觉非常存粹，这也是我希望下去的。</p><p>我也追问过你，也想你在你朋友介绍我，因为缺乏存在感的感受，非常容易令人患得患失，这一切都源于不确定性，一种可取代行。“也许我们的人生进程不着调”，“不同频”。就此问题我回答你：这往后的一年多我没有收入来源，对于你这场恋爱目前看来无疑是不公的，但！相信刘仕林爱你的决心，刘仕林想和你共度未来的决心，你相信我，所以也必然不可能让你输！</p><p>大搀逼，需要个人隐私，想多玩几年，吃软不吃硬，有时候脾气是臭了点，我也尽量给你空间，不让相处这么有负担。</p><p><strong>我们目标一致，一切都不是问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 老婆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学</title>
      <link href="/2023/04/14/%E5%A4%A7%E5%AD%A6/"/>
      <url>/2023/04/14/%E5%A4%A7%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<pre><code>注意，大学期间你可能感到迷茫，当你始终记住一句话，做自己的事情，谋自己的规划，各自有各自赚钱的手段，</code></pre><p>如果有几个交心的朋友是一件很不错的事情但是最主要的还是自己<br>学习方面，不要愚昧的追求像高中时候一样的死读，拼读，没有自己的事情或者事业的情况下可以，<br>但是还是希望能够找到自己感兴趣的事情去做，适应自己的学习情况，保证自己的学业不可以落下，<br>多讲求让自己高效率的完成事情，专心的去做事情，多方向的发展，当你对学习的东西感到很痛苦不解的时候，<br>不妨先<code>“模糊式学习”</code>知道学习的东西的大概框架结构，再一步步对不懂的地方进行细节部分的补充，转变方式<br>明白社会，这时候的你几年之后就要出到社会，这个阶段是你和社会对接的阶段，不能一味的“学生性思维”,<br><code>避免信息闭塞，但一切的根本是讲求于效率！效率！效率！专注！专注！专注！</code><br>感情上的一切不在是那么的单纯，但也不排除有，这时候靠的是自己的表达能力，人格魅力吸引对方，<br>浪漫也只是在这个基础上的锦上添花，是别人想给你的感觉，并不是你自己给自己的个人安慰，不要把自己在别人那边的地位想的太好，<br>没有什么比钱更有说服力的，别和社会关系脱节。<br>刚开始进入大学，很多东西对于你来说都是新鲜的，有兴趣都可以去尝试一下，但是你要明白自己想要的是什么，是体验一下也好，<br>不过不要玩的太深，这些都是你人生中的一小部分而已</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>宝芝林</title>
      <link href="/2023/01/27/%E5%B0%8F%E5%A9%A7/"/>
      <url>/2023/01/27/%E5%B0%8F%E5%A9%A7/</url>
      
        <content type="html"><![CDATA[<center><h4 id="2023-10-24（程序员日）"><a href="#2023-10-24（程序员日）" class="headerlink" title="2023.10.24（程序员日）"></a>2023.10.24（程序员日）</h4><p>刚开始我觉得我不会对你感兴趣的，面试的时候包括第一个星期那两天相处，但是我发现你有几个吸引我的点，现在我还不知道怎么表诉出来。<br>讲真的，有点上头，虽然工作也有很烦恼的时候，但是每天下班能跟你一起走一段也挺解压，今早还在想着会不会在动物园偶遇你，god，还真遇上了<br>good luck’s day. Altough the life’s so bad,but you are sweeter than it,i think it.</p></center><!-- ![让我拍摄稍微有点信心的第一张图](../_posts/小婧/微信图片_20230127120105.jpg) --><!-- 这里本来是有一张你的照片的，但是hexo框架还是这个主题的问题，这个照片渲染不上浏览器 --><h4 id="今天是-10-27"><a href="#今天是-10-27" class="headerlink" title="今天是 10.27"></a>今天是 10.27</h4><p>第一次加班的一天，有点小累，不过还是很愉快的，一起吃的擂椒猪脚饭没有踩雷，又能够跟你一起下班，能跟你聊天，又能了解了你的一些小部分事情。<br>但是也有担忧，陈泽鑫是谁。<br>你在我心里很美好的存在。<br>特别的一天，写个 blog 记录一下</p><h3 id="十一月第一天"><a href="#十一月第一天" class="headerlink" title="十一月第一天"></a>十一月第一天</h3><p>你很想知道我为什么不去一起吃饭，因为我</p><h4 id="这里在胡说八道讲屁话（删了）"><a href="#这里在胡说八道讲屁话（删了）" class="headerlink" title="这里在胡说八道讲屁话（删了）"></a>这里在胡说八道讲屁话（删了）</h4><center><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4></center><p>❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀</p>]]></content>
      
      
      <categories>
          
          <category> 我的青春 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过去</title>
      <link href="/2023/01/14/%E4%BD%A0/"/>
      <url>/2023/01/14/%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="我心里的那个女孩"><a href="#我心里的那个女孩" class="headerlink" title="我心里的那个女孩"></a>我心里的那个女孩</h5><p>  或许我会忘记我们的很多细节了，时间会冲淡很多东西，但是，<code>杨诗琦</code>这个名字真的会毕生难忘，这个女孩是我的青春，更是像很多人一样，留在青春的遗憾，不知道未来会这么样，但是至少在目前看来是这样的。</p><img src="https://bensonfuck.github.io/images/chushi.jpg" style="zoom:15%;"><p><img> <vedio> <audio> <script> <css>都是自动调用form请求<br>用户点击了页面刷新，就会发送一个新的请求</p><p>重点；<br>浏览器的约定<br>当发送了GET请求时候，浏览器不会带上请求体，任何请求体都会被干掉<br>服务器看得到你的请求体，但是不会理会，只是协议上允许GET发送请求体</p><p>浏览器对行头的大小是有限制的，但是http协议没有固定规定<br>get请求放在行里面的，所有是由规定大小的，但是post请求放在体里面是没有限制大小的<br>URL地址编码，会把”阿斯克“字符，浏览器地址栏显示中文，其实计算机内部传输的是URL地址编码</p><p>get请求方便分享页面，但是post请求不便于分享数据，分享出去请求体没有分享出去<br>post请求数据不会保存在浏览器的</p><h3 id="自动解析响应的能力"><a href="#自动解析响应的能力" class="headerlink" title="自动解析响应的能力"></a>自动解析响应的能力</h3><p>XHR 和 Feach 两个都属于ajax的<br>ajax是调用浏览器的一个模板<br>var xhr = new XMLHTTPRequest();<br>xhr.open();<br>xhr.setRequest();<br>xhr.send();</p><p>js 代码执行，浏览器必须卡死，不能动其他的东西<br>js 的promise的东西</p><p>程序报错：<br>可预料，一定要处理的<br>不可预料，服务器宕机，断网等</p><p>token 令牌<br>出入证就是一种token令牌，</p><p>发送请求的时候就是要设置一个令牌：<br>Authorization: //这个令牌地址不一定，看开发过程中后端要放在哪里</p><p>http协议是一种无状态的协议</p><p>第三节课的内容</p><p>同源策略：<br>就是一套安全机制<br>同源策略对同源资源开放，对<br>两个URL地址完全相同，就是同源，否则就是异元<br>（前端的代码对用户是可见的，前端是不做加密的）<br>验证码不要写前端</p><p>跨源三种场景<br>网络通信：<br>a元素跳跃，加载css，js，图片，ajax等等<br>JS API<br>window.open  window.parent  iframe.contentWindow等等<br>存储<br>WebStorage IndexedDB 等</p><p>同源请求没有任何限制</p><p>跨域的前提条件：在浏览器里面发起的请求才会有跨域问题，“同源”就是浏览器搞出来的<br>脱离了浏览器就没有跨域的问题</p><p>跨域不一定引发问题<br>CORS<br>JSONP<br>代理</p><p>get 和 post 区别<br>根据RFC7231规定，get和post只是请求行的第一个单词，只是表达了不同的语义</p><p>服务器是程序，计算机是物理设备<br>很多bug就是在开发环境没有什么问题，但是一到生产环境（一般指linux）就会出现很多问题<br>这个一般就是代理出的问题<br>生产环境是没有话语的<br>原则：就是跟生产环境保持一致</p></script></audio></vedio></p>]]></content>
      
      
      <categories>
          
          <category> 我的青春 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端网络</title>
      <link href="/2023/01/14/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/01/14/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>学习要点</strong>：</p><ul><li>明白网络在计算机中发挥的作用，分层模型</li><li>使用<code>Ajax</code>做基本操作，</li><li>计算机网络中跨域问题</li></ul><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a><center>理论</center></h4><p><strong>理论的重要性</strong><br>开发过程找不到bug，原因就是理论不牢找不到问题<br>网络部分的理论是非常多而复杂，<br>实践操作的目的就是去理解理论知识点<br>网络解决的问题是两个程序之间交换数据</p><p>[TOC] <strong>分层模型</strong><br>每层相对独立，只解决自己的问题<br>每层无需考虑上层的交付<br>每层有多种解决方案<br>在上一层基础上加上点东西</p><p><strong>五层模型</strong><br><font color="#0099ff">应用层</font>，应用具体消息<strong>格式</strong>（协议就是一个标准）<br><font color="#0099ff">传输层</font>，如何保证消息<strong>可靠传送</strong><br><font color="#0099ff">网络层</font>，就是如何在网络中找到对方 <strong>IP</strong>（目前通讯地址可变） 路由器<br><font color="#0099ff">数据链路层</font>，如何在一个子网中找到对方 <strong>Mac</strong> （身份证号不可变） 交换机<br><font color="#0099ff">物理层</font>，上面给我的东西我要用什么<strong>信号表述</strong></p><p>—<em>国际OSI七层模型就是在应用层和传输层加多一个表示层和会话层</em>—</p><p>[toc]UML用于定位网络<font color="#0099ff"> 服务 </font>，就是一个<strong>字符串</strong><br>URL（uniform resource locator，统一资源定位符）用于定位网络服务</p><p><img src="http://mdrs.yuanjin.tech/img/202301121041726.png" alt="image-20230112104100679"></p><p>URL是一个固定格式的字符串<br><em>表示形式</em></p><p><img src="http://mdrs.yuanjin.tech/img/202301121029498.png" alt="URL流程表示图"></p><p>它表达了：</p><p>从网络中<font color="#0099ff">哪台计算机（domain）</font>中的<font color="#0099ff">哪个程序（port）</font>寻找<font color="#0099ff">哪个服务（path）</font>，并注明了获取服务的<font color="#0099ff">具体细节（path）</font>，以及要用什么样的<font color="#0099ff">协议通信（schema）</font></p><!-- http默认端口：80 ，https默认端口：443没有写路径的时候，就是最后面会有一个斜杠，就是默认地址https://www.baidu.com/不然浏览器也会默认加上一个/ --><ul><li>当协议是<code>http</code>端口为<code>80</code>时，端口可以省略</li><li>当协议是<code>https</code>端口为<code>443</code>时，端口可以省略</li><li><code>schema</code>、<code>domain</code>、<code>path</code>是必填的，其他的根据具体的要求填写</li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><ul><li>传递消息的<font color="#0099ff">模式</font></li><li>传递消息的<font color="#0099ff">格式</font><br><em>发起者是客户端client，接收者是服务器server（<strong>舔狗和女神</strong>）</em></li><li>格式<br>请求行Line      客户端发送的是纯文本<br>请求头Header<br>请求体Body</li></ul><p>请求方式 post（提交） / get（获取） / delete（删除） / put（修改）</p><blockquote><p>使用情况：<br><font color="#0099ff">获取</font>数据一般使用<code>GET</code><br><font color="#0099ff">提交</font>数据一般使用<code>POST</code><br>各种<font color="#0099ff">静态资源</font>的获取，一般使用<code>GET</code></p></blockquote><h5 id="请求方法之间只有语义的区别"><a href="#请求方法之间只有语义的区别" class="headerlink" title="请求方法之间只有语义的区别"></a>请求方法之间<strong>只有</strong>语义的区别</h5><h4 id="请求头：host"><a href="#请求头：host" class="headerlink" title="请求头：host"></a>请求头：host</h4><p>可以定义一种请求格式，官方没有特定要求<br><code>Host</code>标注了<code>URL</code>地址中的<code>Domain + Port</code><br>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST:study.baidu.com</span><br></pre></td></tr></tbody></table></figure><h4 id="请求头：Content-Type"><a href="#请求头：Content-Type" class="headerlink" title="请求头：Content-Type"></a>请求头：Content-Type</h4><p>比如，请求体的数据为<code>loginId:admin, loginPwd:123456</code>，请求体可以用不同的格式发出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">loginId=admin&amp;loginPwd=123123</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">{ "loginId": "admin", "loginPwd": "123123" }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryraPtlntBIqy4X2Ho</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryraPtlntBIqy4X2Ho</span><br><span class="line">Content-Disposition: form-data; name="loginId"</span><br><span class="line"></span><br><span class="line">admin</span><br><span class="line">------WebKitFormBoundaryraPtlntBIqy4X2Ho</span><br><span class="line">Content-Disposition: form-data; name="loginPwd"</span><br><span class="line"></span><br><span class="line">123456</span><br><span class="line">------WebKitFormBoundaryraPtlntBIqy4X2Ho--</span><br></pre></td></tr></tbody></table></figure><p><code>Content-Type</code>标注了附带的响应体是什么格式<br>常见的值有：</p><ol><li><code>text/plain</code>: 普通的纯文本</li><li><code>text/html</code>：html文档</li><li><code>text/javascript</code> 或 <code>application/javascript</code>：js代码</li><li><code>text/css</code>：css代码</li><li><code>image/jpeg</code>：jpg图片</li><li><code>attachment</code>：附件</li><li>其他<code>MIME</code>类型<br>tip：<br>这个没有固定标准</li></ol><h4 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h4><p>常用的响应码：<br><img src="http://mdrs.yuanjin.tech/img/202301121310570.png" alt="响应码标识"></p><ul><li><p><strong>200 OK：一切正常。</strong></p></li><li><p><strong>301 Moved Permanently：资源已被永久重定向。</strong></p><p> <code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我已经永远的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了响应头的Location中了</code></p><blockquote><p>试试请求：<a href="http://www.douyutv.com/">www.douyutv.com</a></p></blockquote></li><li><p><strong>302 Found：资源已被临时重定向。</strong></p><p> <code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我临时的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了请求头的Location中了</code></p></li><li><p><strong>304 Not Modified：文档内容未被修改。</strong></p><p> <code>你的请求我收到了，你要的东西跟之前是一样的，没有任何的变化，所以我就不给你结果了，你自己就用以前的吧。啥？你没有缓存以前的内容，关我啥事</code></p></li><li><p><strong>400 Bad Request：语义有误，当前请求无法被服务器理解。</strong></p><p> <code>服务器无法解析请求报文</code></p></li><li><p>403 Forbidden：服务器拒绝执行。**</p><p> <code>服务器不给东西给你</code></p></li><li><p><strong>404 Not Found：资源不存在。</strong></p><p> <code>你的请求我收到了，但我没有你要的东西</code></p></li><li><p><strong>500 Internal Server Error：服务器内部错误。</strong></p><p> <code>你的请求我已收到，但这道题我不会，解不出来，先睡了</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Make you first blog</title>
      <link href="/2023/01/11/My-first-blog/"/>
      <url>/2023/01/11/My-first-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>hexo</code>是一个静态博客搭建框架，由 javaScript 实现，所以要调用到js服务端的node环境，与之相同的有：<br><code>hugo</code> (go语言实现的框架，大量信息情况下速度比hexo快)<br>除了静态博客框架，还有<code>WordPress</code>动态博客框架，可以放置到服务器根据用户需求注册账户等服务器端操作</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p><u>默认git，node，npm镜像配置完成</u><br>创建一个 blog 文件夹存放博客文件<br>首先要安装 <code>node npm</code> 两个服务<br>使用 npm 全局安装 <code>hexo-cli</code> 服务</p><p>###基本 hexo 命令使用<br><code>hexo init</code><strong>初始化</strong> hexo 文件，给定基础配置<br><code>hexo s</code> (start)<strong>启动</strong>本地博客，默认端口号: <code>localhost:4000</code><br><code>hexo n</code> (new)<strong>创建</strong>一个新的博客文章<br><code>hexo clean</code> (清理)写完博客文章后，<strong>清理数据</strong><br><code>hexo g</code> (刷新)对数据进行<strong>刷新</strong><br><code>hexo d</code> <strong>提交</strong>到github仓库<br><code>hexo new page </code><strong>创建page</strong>，就是创建一个新文件夹<br><code>hexo new fileName</code><strong>创建文件</strong>,文件创建在<code>/sourse/_post</code>下</p><h3 id="部署到-github-仓库"><a href="#部署到-github-仓库" class="headerlink" title="部署到 github 仓库"></a>部署到 github 仓库</h3><p>1.在自己的 github 上面<em>搭建一个仓库</em>，注意：<code>仓库名要是自己的用户名.github.io </code><br>2.使用 npm 装一个 git <em>部署插件</em> 命令：<code>npm install -g -save hexo-deployer-git </code><br>3.<em>修改配置</em> _config.yml 文件的 deploy：</p><blockquote><p>type: git<br>repo: github仓库http地址<br>branch: masten  (指向空指针的意思) </p></blockquote><p>Tip：<br>如果显示 <code>not fround git</code> 说明插件没安装好,再次尝试安装<br>window 电脑不需要再使用 github 用户密码登陆，直接推到远端<br>但是 linux 和 unix 相反</p><h3 id="修改主题，进行自定义"><a href="#修改主题，进行自定义" class="headerlink" title="修改主题，进行自定义"></a>修改主题，进行自定义</h3><p><code>clone</code> 上面的主题到：<code>/themes</code>里面<br>修改主题文件还是 _config.yml 内：</p><blockquote><p>theme：landspace(修改)<br>剩下的看文档介绍自定义主题</p></blockquote><h4 id="hexo框架操作注意："><a href="#hexo框架操作注意：" class="headerlink" title="hexo框架操作注意："></a>hexo框架操作注意：</h4><ul><li>window系统要安装git</li></ul><ul><li>必须是通过hexo命令创建的文件才可以被使用</li><li>我使用的是<code>hexo-theme-matery</code>主题，该主题分类关键字在页面中的<code>category</code>，在<code>_config.yml</code> 文件中配置命名，<code>/fileName/name/</code>fileName是用hexo命令创建的</li><li>我所使用主题下分类基本都在“分类”栏下，</li><li>hexo生成文件不可以直接修改文件名称</li><li>在hexo的根目录下，打开管理员命令行端口</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><code>hexo d</code> 命令使用：npm包下面的<code>hexo-deployer-git@4.0.0</code>插件，该插件本身问题：内存泄漏或资源竞争问题（连续多次提交重构容易造成冲突会崩溃出现<code>Error:spawn failed</code>）。对此下策<code>npm uninstall</code>再<code>cnpm install hexo-deployer-git --save</code><br><code>github actions</code>里面查看当前重构推送详情</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>@CodeSheep<br>@fi3ework</p>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
