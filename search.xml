<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javaEE加强</title>
      <link href="/2025/11/15/javaEE%E5%8A%A0%E5%BC%BA/"/>
      <url>/2025/11/15/javaEE%E5%8A%A0%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="javaEE基础加强"><a href="#javaEE基础加强" class="headerlink" title="javaEE基础加强"></a>javaEE基础加强</h3><ol><li>异常，泛型，集合框架</li><li>stream流</li><li>File，字符集，IO流框架</li><li>多线程</li><li>网络编程</li><li>java高级技术</li></ol><h6 id="异常体系（java-lang-Throuable）"><a href="#异常体系（java-lang-Throuable）" class="headerlink" title="异常体系（java.lang.Throuable）"></a>异常体系（java.lang.Throuable）</h6><p>Error：是系统级别的异常，Sun公司自己用的</p><p>Exception（开发人员控制）：</p><ul><li>Runtime Exception:运行异常</li><li>其他异常（红线提醒）</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用try（）{}catch{} 捕获异常，（）内为执行后close（）线程部分，可以省略</span></span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    </span><br><span class="line">}<span class="keyword">catch</span>(Exception e){</span><br><span class="line">    e.  <span class="comment">// 调用打印输出异常内容</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctrl+enter将异常抛出到上一层</span></span><br></pre></td></tr></tbody></table></figure><p>tip：idea中ctrl + alt + t 快速创建try{…}catch{…}</p><p>异常作用：</p><p>可以作为方法的一种特殊返回值，以便通知上层调用者方法执行问题(外抛异常： <code>throw   new  Exception(" ");</code>)</p><p>异常：代码编译或运行时可能出现的错误</p><p>自定义异常:</p><p>java无法为世界上全部问题提供异常类来代表（java目前逐步放弃编译异常，以运行异常为主）</p><h6 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h6><ol><li>抛出异常提示信息</li><li>最外层捕获异常后，尝试修复</li></ol><h6 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h6><p>定义类，接口，方法时，同时声明了一个或多个类型变量（如：<e> ）</e></p><p>作用：在编译阶段约束所能操作的数据类型，并自动进行检查能力</p><p>本质：把具体的变量类型传给类型变量</p><p><strong>泛型接口方法（架构师）</strong>：</p><p>建类变量用 E（元素类型），T（返回Type），K（键类型），V（值类型）全部大写</p><p>方法，通配符，上下限</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> (name) (T (name))</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T (name) (T (name))</span><br></pre></td></tr></tbody></table></figure><p>tip:通配符就是“？”  可以使用泛型代表一切类型，ETKV是定义泛型时使用</p><p><strong>通配符问题，其他什么狗也能进来，于是引出上下限</strong></p><p>泛型上限：<code>? extends Car:?</code>  能接Car或其子类</p><p>泛型下限：<code>? super Car:?</code>  能接Car或其父类</p><p><strong>泛型不支持的基本数据类型，只支持对象类型（引用数据类型）</strong></p><p>解决方式（包装类），万物皆对象的思想</p><p>基本数据类型包装成对象的类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> -&gt; Integer</span><br><span class="line"><span class="type">char</span> -&gt; Character </span><br><span class="line"><span class="comment">// 其他基本是首字母大写</span></span><br><span class="line"><span class="comment">// 这就转成了对象类型</span></span><br></pre></td></tr></tbody></table></figure><p>手动包装：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">it1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>); <span class="comment">// -128~127 源码</span></span><br><span class="line">it1 == it2;  <span class="comment">//一个cache缓存</span></span><br></pre></td></tr></tbody></table></figure><p>自动装箱：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add();  <span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.get(); <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></tbody></table></figure><p>Api：</p><p><code>Integer.parseInt(String s)</code> 把字符串类型的数值转换成数值本身对应的真实类型</p><p><code>Integer.valueOf(String s)</code>  把基本数据类型转字符串类型</p><p><code>toString(double d)</code></p><p><code>toString()</code></p><h6 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h6><p>（Collection/Map两大框架）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java高级</title>
      <link href="/2025/11/15/java%E9%AB%98%E7%BA%A7/"/>
      <url>/2025/11/15/java%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="java面向对象高级"><a href="#java面向对象高级" class="headerlink" title="java面向对象高级"></a>java面向对象高级</h3><p>（代码块，内部类，函数时编程，常用API，gui编程/不重要）</p><p><strong>代码块是类的5大组成部分：成员变量，构造器，方法，代码块，内部类</strong></p><p><em>API：Arrays,toString(数组名)   //返回数组内容</em></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行顺序（静态代码块 static{}）</span></span><br><span class="line"><span class="comment">* class -&gt; static(对静态资源初始化) —&gt; main（优先执行）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>内部类：</strong></p><p>1.内部类可以直接访问外部类的</p><ul><li>静态成员（static修饰）</li><li>实例成员（无static）</li></ul><p>2.外部类名 .this 可以拿到寄生的外部类对象<code>外部类名.this</code></p><p>静态内部类属于外部类本身（内部类有static修饰）</p><p><code>Outer.Inner oi = new Outer.Inner();</code></p><p><strong>匿名内部类（不用为类声明名字，默认隐藏名字）：</strong></p><p>本质是子类，同时会立即创建一个子类对象  -&gt; 外部类名$ 编号</p><p>用法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(){</span><br><span class="line">    重写方法  <span class="comment">// 立即重写抽象父类方法</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//中段简写：</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">click</span> implements (name)</span><br><span class="line"> click(<span class="keyword">new</span> (name)(){</span><br><span class="line">重写方法</span><br><span class="line"> })</span><br></pre></td></tr></tbody></table></figure><p>API： Arrays.sort() // 排序</p><p><strong>函数式编程：</strong></p><p>Java中函数概念是：Lambda表达式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Swim</span> <span class="variable">s2</span> <span class="operator">=</span> ()-&gt;{</span><br><span class="line">    sout;</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 只能替代函数式接口的内部类，注解： @FuntionalInterface</span></span><br></pre></td></tr></tbody></table></figure><p>Lambda省略规则：</p><ol><li>括号里参数类型全部可以省略</li><li>只有一个参数，参数的{}也可以省略，多个参数不行</li><li>Lambda中只有一行表达式，“{}”不写，“；”省略，有return去掉</li></ol><p>构造器引用：</p><p>​类名::new</p><p><strong>String常用API：</strong></p><p>java.lang 包/自动导的包</p><p>tip: 每次new都会产生一个新对象，在堆内存中</p><p>方式1：（推荐）直接调“ ”创建字符串，封装字符串对象</p><p>方式2：构造器初始化对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">" "</span>);</span><br><span class="line"><span class="type">char</span>[] chars = {<span class="string">'n'</span>,<span class="string">'e'</span>,<span class="string">''</span>,<span class="string">''</span>};</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars); <span class="comment">// 将chars字符转字符串</span></span><br></pre></td></tr></tbody></table></figure><p>提供的方法：</p><ul><li>length()  获取字符串长度</li><li>charAt() 获取索引位置字符返回</li><li>toChatArray() 字符串转字符数组返回</li><li>equals()  判断两个字符串是否一样</li><li>equalsIgonreCase()  忽略大小判断两个字符串是否一样</li><li>substring()  从传入索引处截取到末尾获取新字符串，可以两参/一参</li><li>replace()  用新值替换旧值</li><li>contains()  判断字符串是否包含某个字符</li><li>startsWith()  判断字符串是否有以….开头</li><li>split()  以某个字符分割，并返回字符串</li></ul><p><strong>ArrayList集合：</strong></p><p>创建：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arraylist &lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">Arraylist</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提供add()  remove()  set()  get()  size()方法</span></span><br><span class="line"><span class="comment">* &lt;E&gt;  泛型（后续提到）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>此处略过Gui图形化界面编程…….</p><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2025/11/14/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/11/14/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="day01："><a href="#day01：" class="headerlink" title="day01："></a>day01：</h3><h6 id="idea文件结构-x2F-基础数据类型："><a href="#idea文件结构-x2F-基础数据类型：" class="headerlink" title="idea文件结构/基础数据类型："></a>idea文件结构/基础数据类型：</h6><ul><li><p>工程文件：project-&gt;Model-&gt;packet-&gt;class</p></li><li><p>创建方式: new 一个Emply Project -&gt; 新建Model -&gt; new packet</p></li><li><p>out文件里是javac编译好的.class 文件</p></li><li><p>idea集成ai插件：阿里/通灵码</p><table><thead><tr><th align="left">整形</th><th>浮点型</th><th>字符型</th><th>布尔型</th></tr></thead><tbody><tr><td align="left">byte/short/int/long</td><td>float/double</td><td>char</td><td>boolean</td></tr><tr><td align="left">1/2/4/8</td><td>4byte/8byte</td><td>2byte</td><td>1byte</td></tr><tr><td align="left"></td><td></td><td></td><td></td></tr></tbody></table></li></ul><h3 id="day02"><a href="#day02" class="headerlink" title="day02:"></a>day02:</h3><p>java开发中，<strong>功能的最小单位</strong>是：<strong>方法（函数class）</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名（）{}</span><br><span class="line"><span class="comment">// void 无返回值类型，调用方法时无法用变量接</span></span><br></pre></td></tr></tbody></table></figure><p><strong>方法重载：</strong> 一个类中，多个方法名相同，但形参列表不同，称为方法重载（类型不同，顺序不同，个数不同）</p><h6 id="自动类型-x2F-强制类型转换："><a href="#自动类型-x2F-强制类型转换：" class="headerlink" title="自动类型/强制类型转换："></a><strong>自动类型/强制类型转换：</strong></h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">(<span class="type">byte</span>)i;</span><br><span class="line"><span class="comment">// 强制转换数据类型，装不下会数据溢出</span></span><br></pre></td></tr></tbody></table></figure><h6 id="Scanner（）方法："><a href="#Scanner（）方法：" class="headerlink" title="Scanner（）方法："></a><strong>Scanner（）方法：</strong></h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.io);</span><br><span class="line"><span class="type">int</span> <span class="variable">name</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">// 调用Scanner方法获取用户输入</span></span><br></pre></td></tr></tbody></table></figure><h6 id="分支语句："><a href="#分支语句：" class="headerlink" title="分支语句："></a>分支语句：</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>() <span class="comment">// if...else if判断语句</span></span><br><span class="line"><span class="keyword">switch</span>() <span class="comment">// switch...case 1: 选择语句</span></span><br></pre></td></tr></tbody></table></figure><h6 id="循环结构："><a href="#循环结构：" class="headerlink" title="循环结构："></a>循环结构：</h6><p>作用：减少重复代码</p><p>for：知道循环次数</p><p>while：不知道循环次数</p><p>do…while：先do再while判断</p><p>print：不换行打印</p><p>println：换行打印</p><p><strong>循环嵌套：</strong> <em><strong>外部循环执行一次，内部循环整体会完整执行一轮</strong></em> </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++){</span><br><span class="line">    sum += i;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// for循环语句，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(sum == <span class="number">0</span>){</span><br><span class="line">    <span class="comment">// 判断完执行循环体，写死循环好用</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">do</span>{</span><br><span class="line">  <span class="comment">// 业务很少使用  </span></span><br><span class="line">}<span class="keyword">while</span>（）</span><br></pre></td></tr></tbody></table></figure><h3 id="day03："><a href="#day03：" class="headerlink" title="day03："></a>day03：</h3><h6 id="猜数字程序："><a href="#猜数字程序：" class="headerlink" title="猜数字程序："></a>猜数字程序：</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Randow()方法生成随机数</span></span><br><span class="line"><span class="comment">// Math.randow() 方法(java内置，返回[0,1]随机小数)</span></span><br><span class="line"><span class="comment">// 例：(Math.randow() * 100) + 1</span></span><br><span class="line"><span class="type">Randow</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Randow</span>();</span><br><span class="line">r.nextInt(<span class="number">100</span>); <span class="comment">// 随机生成[0,99]的随机数</span></span><br><span class="line">Math.sqrt(); <span class="comment">// 一个数的开平方</span></span><br><span class="line">isprime（）; <span class="comment">// 判断是否为1或0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的创建 （二维数组在此基础上加）</span></span><br><span class="line"><span class="comment">// 底层还是new创建对象</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]{};</span><br><span class="line"><span class="comment">// 日常写法：</span></span><br><span class="line"><span class="type">int</span> arr[] = {};</span><br></pre></td></tr></tbody></table></figure><h3 id="面向对象编程（万物皆对象）："><a href="#面向对象编程（万物皆对象）：" class="headerlink" title="面向对象编程（万物皆对象）："></a>面向对象编程（万物皆对象）：</h3><p>[class  类] 自己定义模板</p><p>封装的class里可以写功能： </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名(){}</span><br><span class="line"><span class="comment">// 采用.方法名 调用方式</span></span><br></pre></td></tr></tbody></table></figure><p><strong>每new一次都在JVM内存中，main方法归属于栈内存，定义变量再堆内存</strong></p><h6 id="类的基本语法（IDEA中右键生成）："><a href="#类的基本语法（IDEA中右键生成）：" class="headerlink" title="类的基本语法（IDEA中右键生成）："></a><strong>类的基本语法（IDEA中右键生成）：</strong></h6><ul><li>构造器（有参构造器/无参构造器，类名必须和方法名一样）</li><li>this （指代方法作用范围内的变量，哪个对象调用这个方法，this就拿到这个对象，解决变量名冲突问题）</li><li>封装</li><li>Javabean</li><li>static</li></ul><h6 id="oob3大特征："><a href="#oob3大特征：" class="headerlink" title="oob3大特征："></a>oob3大特征：</h6><ul><li><h6 id="封装-（类，方法都是一种封装思想：合理隐藏，合理暴露）"><a href="#封装-（类，方法都是一种封装思想：合理隐藏，合理暴露）" class="headerlink" title="封装  （类，方法都是一种封装思想：合理隐藏，合理暴露）"></a>封装  （类，方法都是一种封装思想：<u>合理隐藏，合理暴露</u>）</h6></li><li><p><strong>继承</strong> </p></li><li><p>**多态 **</p></li></ul><p><em>使用 <code>private</code> 关键字修饰的成员变量，就只能在本类中直接访问</em></p><p><strong>class类中定义方法：get()  /  set()方法对象公开操作</strong></p><p>java规范：</p><ol><li>公开成员，用 <code>public</code> 公开</li><li>私有成员，用 <code>private</code> 私有</li></ol><p><strong>javabean（特殊类，实体类）：</strong></p><p>业务功能（对实体类操作定义在这一类上）</p><p>static：静态，修饰成员变量，成员方法（类变量，只加载一份，被类和类的全部对象共享访问）属于类</p><p>无static修饰(实例变量)    属于对象，每个对象都有一份</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>(){}</span><br><span class="line"><span class="comment">// 类名.  访问静态变量（Student.name）</span></span><br><span class="line"><span class="comment">// 对象名   student sc = new student();  sc.name;</span></span><br></pre></td></tr></tbody></table></figure><p>规范：</p><ol><li>方法只是为了做一个功能且不需要直接访问对象数据，定义静态方法</li><li>方法只是对象行为，要访问对象数据，定义实例方法</li></ol><p>用途：定义工具类，可以用类名直接”.”访问</p><p>（私有对象，没必要new出来，里加  private  类名 () {}   ）</p><h6 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>{}</span><br></pre></td></tr></tbody></table></figure><p>子类继承父类的非私有成员（成员变量，成员方法）</p><h6 id="四种权限修饰符："><a href="#四种权限修饰符：" class="headerlink" title="四种权限修饰符："></a>四种权限修饰符：</h6><table><thead><tr><th>private</th><th>缺省</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>只能本类</td><td>本类，同一个包的类</td><td>本类，同一个包，子孙类中</td><td>任意位置</td></tr></tbody></table><p><strong>特点：</strong></p><ol><li>单继承</li><li>java中的类不支持多继承（不能多个父）</li><li>支持多层继承（父，爷.）</li><li>祖宗类：Object，默认继承</li></ol><p>if 子父类同一（重名）成员变量，访问父类的变量，用super()。</p><p><strong>方法重写：</strong></p><p>继承父类的方法，一个方法名，参数列表一样的方法去覆盖</p><p>方法名（参数形参）  和父一致，重写内容。      头加+注解：<code>@Override</code>（标志注解：优雅，安全）</p><p>子类constructor，都会先调用父类的construtor 再调用自己的constructor.</p><p>this（…） 调兄弟构造器，super（…）必须写在构造器第一行，</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li><p>对象多态</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译看左边，运行看右边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>{} <span class="comment">// </span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">wolf</span>();  <span class="comment">// (子)</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tortoise</span>; <span class="comment">// （子）extends继承关系</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>行为多态</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过重写run（）方法。tip：变量不谈多态</span></span><br><span class="line">s1.run();</span><br><span class="line">s2.run();</span><br></pre></td></tr></tbody></table></figure></li></ul><p>条件：</p><ol><li>有继承/实现关系</li><li>存在父类引用子类对象关系 <code>Animal a1 = new wolf();</code></li><li>存在重写方法（必须）—行为多态</li><li>多态下不能调用子类独有功能</li></ol><p>用法：</p><p><code>new</code>  （多态） 后续用到I/O流，Stream流，列表等都会多态写法</p><p>类型转换：解决多态下不能调独有功能情况</p><p>​自动。父类变量名=new 子类（）；</p><p>​强制。子类变量名= （子类）父类变量；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ide中的注解，用于生成getter，setter，无参构造器，toString（）方法</span></span><br><span class="line"><span class="comment">// 必须要导包，不用的话手动生成</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">// 自动生成有参构造器</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span><span class="comment">// 自动生成无参构造器</span></span><br></pre></td></tr></tbody></table></figure><h4 id="面向对象的高级（final，单例类，枚举类，抽象类，接口）"><a href="#面向对象的高级（final，单例类，枚举类，抽象类，接口）" class="headerlink" title="面向对象的高级（final，单例类，枚举类，抽象类，接口）"></a>面向对象的高级（final，单例类，枚举类，抽象类，接口）</h4><p><strong>final：</strong></p><table><thead><tr><th>修饰类</th><th>修饰方法</th><th>修饰变量</th></tr></thead><tbody><tr><td>为最终类，不能被继承</td><td>为最终方法，不能被重写</td><td>为最终变量，该变量只能被赋值一次</td></tr></tbody></table><p><strong>变量（tip：常量全大写，用”_”连接）：</strong></p><table><thead><tr><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>静态成员变量（final修饰静态成员变量，称为常量）<br>实例成员变量</td><td>for循环体中的这类</td></tr></tbody></table><p>静态：<code>public static final String SCHOOL_NAME = "";</code></p><p>实例：<code>public final String name = "" // 没意义</code></p><p><strong>单例类（软件设计模式，架构师级）</strong></p><p>设计模式：n种解法种最优解，此最优解被总结出来，称为设计模式</p><p>“单例设计模式”（类似任务管理器，只能开一个）</p><p>作用：确保某个类只能创建一个对象</p><ul><li>饿汉单例：<ol><li>私有化构造器，<code>private  类名 （）{}</code></li><li>定私有化类变量，记住一个类的一个对象，<code>private static (class name) a = new  (class name);</code></li><li>定义一个公开方法返回类变量，<code>public static  (name) (){return  a;}</code></li></ol></li><li>懒汉单例：<ol><li>私有化构造器</li><li>定义静态私有化类变量，不new “b”</li><li>定义公开的类方法判断  <code> b == null,b = new B();</code> ，并返回b（类 method）</li></ol></li></ul><p><strong>枚举类（public enum A(){}）：</strong></p><p>tip: javap可以反编译java文件</p><ul><li>.name()拿对象名 </li><li>.ordinal()      拿对象索引</li></ul><p>枚举类  extends  java.lang.Enum<a>   // 所以不能继承其他；</a></p><p>​</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">enum</span>  <span class="title class_">A</span>（）{</span><br><span class="line"></span><br><span class="line">x； <span class="comment">// 也是个单例对象</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>应用场景：信息分类和信息标志</p><p><strong>抽象类：</strong></p><p>Java关键字 Abstract,修饰类，成员方法</p><p>作用：就是被子类继承</p><p>使用方法：子类继承父类时，父类只写 <code>public abstract void  (name)();</code>  (便于重写父类代码)</p><p><strong>模板方法设计模式（解决代码重复问题）：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">name</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>{</span><br><span class="line">        sout;</span><br><span class="line">        sout;</span><br><span class="line">        writeMain();</span><br><span class="line">        sout;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">writeMain</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 模板方法调用抽象类方法（Tip：最好用final修饰，不能被重写）</span></span><br></pre></td></tr></tbody></table></figure><p><strong>接口（interface）：</strong></p><p>用处：</p><ol><li><p>弥补类单继承问题（继承多个）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Driver</span>{}</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BoyFriend</span>{}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>{}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">extends</span> <span class="title class_">People</span> implement Driver,BoyFriend{}</span><br></pre></td></tr></tbody></table></figure></li><li><p>可实现面向接口编程，更利于解耦合</p></li></ol><p>接口被类实现（implement）的，称：实现类。一个类可以实现多个接口</p><p>注意：必须实现接口的所有抽象方法（或定义为抽象类）</p><p><em>JDK8后新增：</em></p><p><code>default void test1(){} //实例方法，实现类new出调</code></p><p><code>private void test2(){} // 私有方法，接口中调</code></p><p><code>static void test3(){} // 静态方法，接口名调用</code></p><p><strong>接口注意事项：</strong></p><ol><li><p>接口与接口可以多继承 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span><span class="keyword">interface</span> <span class="title class_">B</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span><span class="keyword">extends</span> <span class="title class_">A</span>,B</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>一个接口中继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承，也不支持多实现</p></li><li><p>一个类继承父类，又同时实现接口，如果父类中和接口同名的方法，实现类优先用父类的</p></li><li><p>一个类实现多个接口，如果多个接口存在同名的默认方法，可以不冲突，这个类重写该方法即可</p></li></ol><p><strong>抽象类，接口对比</strong></p><p>相同：</p><ul><li>都是抽象形式，可抽象方法，不能创建对象</li><li>都是派生子类形式，抽象类被子类继承使用，接口被实现类</li><li>类继承子类或接口，都要重写抽象方法</li><li>都支持多态，实现解耦合</li></ul><p>不同：</p><ul><li>抽象类定义全部成员变量，接口定义常量</li><li>单继承</li><li>接口更适合做解耦合，更灵活</li><li>抽象类体现模板思想，更适合做父类继承</li></ul><p>tip：boolean值不是get method，是is</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>产品经理入门</title>
      <link href="/2025/11/10/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%85%A5%E9%97%A8/"/>
      <url>/2025/11/10/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="产品经理"><a href="#产品经理" class="headerlink" title="产品经理"></a>产品经理</h2><ul><li>产出：1份立项的文档，一份产品结构图，一套项目原型</li></ul><p><strong>想清楚产品怎么做的人</strong></p><p>合格产品包括啊：</p><ol><li><strong>用户，场景，需求</strong></li><li><strong>功能，体验/优势，价值</strong></li></ol><h2 id="产品经理分类"><a href="#产品经理分类" class="headerlink" title="产品经理分类"></a>产品经理分类</h2><table><thead><tr><th>产品</th><th>公司</th></tr></thead><tbody><tr><td>服务对象</td><td>行业/职级</td></tr><tr><td>平台</td><td>工作内容</td></tr></tbody></table><h3 id="面向服务对象区分"><a href="#面向服务对象区分" class="headerlink" title="面向服务对象区分"></a><strong>面向服务对象区分</strong></h3><table><thead><tr><th>C端产品经理</th><th>B端产品经理</th><th>G端产品经理</th></tr></thead><tbody><tr><td>面向普通用户</td><td>面向公司内部系统或外部企业</td><td>面向政府部门，政务服务公共类产品</td></tr><tr><td>如：淘宝，微信</td><td>如：OA，CRM或者SaaS类产品</td><td>如：政务服务网站，公安系统，户政系统</td></tr></tbody></table><h3 id="按产品不同区分"><a href="#按产品不同区分" class="headerlink" title="按产品不同区分"></a><strong>按产品不同区分</strong></h3><table><thead><tr><th>移动端产品经理</th><th>PC客户端产品经理</th><th>Web端产品经理</th><th>智能硬件产品经理</th></tr></thead><tbody><tr><td>手机应用程序，H5页面</td><td>手机桌面引用程序</td><td>网页相关前后台</td><td>软件硬件结合家居，医疗，汽车，穿戴设备</td></tr></tbody></table><h3 id="公司所属行业不同"><a href="#公司所属行业不同" class="headerlink" title="公司所属行业不同"></a><strong>公司所属行业不同</strong></h3><table><thead><tr><th>教育产品经理</th><th>电商产品经理</th><th>金融产品经理</th><th>医疗产品经理</th><th>社交产品经理</th></tr></thead><tbody><tr><td>xx教育</td><td>淘宝，京东</td><td>支付宝，财付通</td><td>春雨医生，健康160</td><td>微信，QQ</td></tr></tbody></table><h3 id="按工作内容划分"><a href="#按工作内容划分" class="headerlink" title="按工作内容划分"></a><strong>按工作内容划分</strong></h3><table><thead><tr><th>功能产品经理</th><th>策划产品经理</th><th>商业产品经理</th><th>数据产品经理</th><th>用户体验产品经理</th></tr></thead><tbody><tr><td>专注产品功能规划设计，基于用户需求和业务改进点设计页面功能</td><td>专注设计策划方案，如根据用户生命周期，设计用户增长策略，根据用户画像推进策略等</td><td>参与商业化运营决策，商业变现模式设计，对收入利润和ROI负责，营收场景设计，广告变现等</td><td>专注设计数据中台和大数据中台相关数据产品解决方案，研究数据价值，数据驱动决策</td><td>专注用户体验设计，理解用户心理，关注交互，UI等交互体验和视觉效果</td></tr></tbody></table><ul><li>职级划分</li></ul><ol><li>产品专员/助理（原型设计，文档撰写）</li><li>产品经理（对自己负责的模块有话语权和决策权）</li><li>高级产品经理（负责某个产品线或业务线）</li><li>产品总监（多个产品线或业务线负责人）</li></ol><h2 id="产品开发流程"><a href="#产品开发流程" class="headerlink" title="产品开发流程"></a>产品开发流程</h2><table><thead><tr><th>分析定义</th><th>软件设计</th><th>编码测试</th><th>运行维护</th></tr></thead><tbody><tr><td>问题定义</td><td>概要设计</td><td>程序编码</td><td>运行维护</td></tr><tr><td>可行性研究</td><td>详细设计</td><td>集成测试</td><td></td></tr><tr><td>需求分析</td><td></td><td></td><td></td></tr></tbody></table><ul><li><p><strong>产品技术中心</strong></p><ol><li>产品设计部</li></ol><ul><li><em>产品经理</em><br>  <em>平面设计师</em><br>  <em>交互设计师</em></li></ul><ol start="2"><li>研发部</li></ol><ul><li><em>前端工程师</em><br>  <em>后端工程师</em><br>  <em>运维工程师</em><br>  <em>测试工程师</em></li></ul><ol start="3"><li>项目组</li></ol><ul><li><em>项目经理</em>（不一定每个公司有）</li></ul></li></ul><h3 id="前端工程师"><a href="#前端工程师" class="headerlink" title="前端工程师"></a>前端工程师</h3><pre><code> 网站，app，小程序</code></pre><h3 id="后端工程师"><a href="#后端工程师" class="headerlink" title="后端工程师"></a>后端工程师</h3><pre><code>平台设计，接口设计，功能实现</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>正确，完整，安全，质量保证</code></pre><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><pre><code>服务器，操作系统，数据库</code></pre><h3 id="项目经理职责"><a href="#项目经理职责" class="headerlink" title="项目经理职责"></a>项目经理职责</h3><pre><code>制定项目管理计划组建项目团队跟踪项目进度监控项目质量控制项目成本</code></pre><h3 id="产品经理职责"><a href="#产品经理职责" class="headerlink" title="产品经理职责"></a>产品经理职责</h3><pre><code>评估产品机会    1. 需求收集    2. 可行性研究 ---&gt; MRD（市场需求文档）/立项报告定义要开发产品    1. 需求分析    2. 原型设计</code></pre><h3 id="用户体验设计师"><a href="#用户体验设计师" class="headerlink" title="用户体验设计师"></a>用户体验设计师</h3><pre><code>用户界面设计/UI    1. 视觉效果    2. 界面图标 ---&gt; 效果图/icon用户交互设计/UE    1. 动作交互    2. 反馈体验 ---&gt; 交互稿</code></pre><ul><li>工作误区<br>  画原型的<br>  管理项目的（关注产品本身）<br>  需求混淆（老板用户自己需求不等于产品需求）<br>  职权混淆（对产品生命周期负责，驱动同事写作，属同级）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>6年后我们在一起了</title>
      <link href="/2025/11/07/6%E5%B9%B4%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86/6%E5%B9%B4%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86/"/>
      <url>/2025/11/07/6%E5%B9%B4%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86/6%E5%B9%B4%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h2 id="幸福（2025-10-21-10-26）-杨诗琦"><a href="#幸福（2025-10-21-10-26）-杨诗琦" class="headerlink" title="幸福（2025.10.21-10.26）_ 杨诗琦"></a>幸福（2025.10.21-10.26）_ 杨诗琦</h2><p>白云机场落地见到你的一刻，恍惚这 6 年的时间。我们曾经无数个日夜的牵绊，也经历不少的吵闹，都是 17，19 的繁华记忆<br>这些年不曾敢打扰，也经历了各自的生活，感谢源于 24 岁的杨诗琦勇敢的走出这一步<br>6 年化为这 6 天时光，很开心也很幸福，我们牵着手走在广州的街头。体育西，天河城，维多利广场，沙面，永庆坊，祖庙，西华路，万胜围。一起拍了人生中第一张红底合照，一起搭上驶向广州塔的有轨电车，品尝了各式各样的“清汤寡水”，但都因为和你一起，真的让人迷醉在幸福里<br>5 个晚上的沟通，促进了你我，你告诉我你爱我的决心，也告诉我想和我结婚，没有任何退路。而刘仕林是真的真的想给你个未来，也会为之努力！</p>]]></content>
      
      
      <categories>
          
          <category> 老婆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学</title>
      <link href="/2023/04/14/%E5%A4%A7%E5%AD%A6/"/>
      <url>/2023/04/14/%E5%A4%A7%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<pre><code>注意，大学期间你可能感到迷茫，当你始终记住一句话，做自己的事情，谋自己的规划，各自有各自赚钱的手段，</code></pre><p>如果有几个交心的朋友是一件很不错的事情但是最主要的还是自己<br>学习方面，不要愚昧的追求像高中时候一样的死读，拼读，没有自己的事情或者事业的情况下可以，<br>但是还是希望能够找到自己感兴趣的事情去做，适应自己的学习情况，保证自己的学业不可以落下，<br>多讲求让自己高效率的完成事情，专心的去做事情，多方向的发展，当你对学习的东西感到很痛苦不解的时候，<br>不妨先<code>“模糊式学习”</code>知道学习的东西的大概框架结构，再一步步对不懂的地方进行细节部分的补充，转变方式<br>明白社会，这时候的你几年之后就要出到社会，这个阶段是你和社会对接的阶段，不能一味的“学生性思维”,<br><code>避免信息闭塞，但一切的根本是讲求于效率！效率！效率！专注！专注！专注！</code><br>感情上的一切不在是那么的单纯，但也不排除有，这时候靠的是自己的表达能力，人格魅力吸引对方，<br>浪漫也只是在这个基础上的锦上添花，是别人想给你的感觉，并不是你自己给自己的个人安慰，不要把自己在别人那边的地位想的太好，<br>没有什么比钱更有说服力的，别和社会关系脱节。<br>刚开始进入大学，很多东西对于你来说都是新鲜的，有兴趣都可以去尝试一下，但是你要明白自己想要的是什么，是体验一下也好，<br>不过不要玩的太深，这些都是你人生中的一小部分而已</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>宝芝林</title>
      <link href="/2023/01/27/%E5%B0%8F%E5%A9%A7/"/>
      <url>/2023/01/27/%E5%B0%8F%E5%A9%A7/</url>
      
        <content type="html"><![CDATA[<center><h4 id="2023-10-24（程序员日）"><a href="#2023-10-24（程序员日）" class="headerlink" title="2023.10.24（程序员日）"></a>2023.10.24（程序员日）</h4><p>刚开始我觉得我不会对你感兴趣的，面试的时候包括第一个星期那两天相处，但是我发现你有几个吸引我的点，现在我还不知道怎么表诉出来。<br>讲真的，有点上头，虽然工作也有很烦恼的时候，但是每天下班能跟你一起走一段也挺解压，今早还在想着会不会在动物园偶遇你，god，还真遇上了<br>good luck’s day. Altough the life’s so bad,but you are sweeter than it,i think it.</p></center><!-- ![让我拍摄稍微有点信心的第一张图](../_posts/小婧/微信图片_20230127120105.jpg) --><!-- 这里本来是有一张你的照片的，但是hexo框架还是这个主题的问题，这个照片渲染不上浏览器 --><h4 id="今天是-10-27"><a href="#今天是-10-27" class="headerlink" title="今天是 10.27"></a>今天是 10.27</h4><p>第一次加班的一天，有点小累，不过还是很愉快的，一起吃的擂椒猪脚饭没有踩雷，又能够跟你一起下班，能跟你聊天，又能了解了你的一些小部分事情。<br>但是也有担忧，陈泽鑫是谁。<br>你在我心里很美好的存在。<br>特别的一天，写个 blog 记录一下</p><h3 id="十一月第一天"><a href="#十一月第一天" class="headerlink" title="十一月第一天"></a>十一月第一天</h3><p>你很想知道我为什么不去一起吃饭，因为我</p><h4 id="这里在胡说八道讲屁话（删了）"><a href="#这里在胡说八道讲屁话（删了）" class="headerlink" title="这里在胡说八道讲屁话（删了）"></a>这里在胡说八道讲屁话（删了）</h4><center><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4></center><p>❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀❀</p>]]></content>
      
      
      <categories>
          
          <category> 我的青春 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过去</title>
      <link href="/2023/01/14/%E4%BD%A0/"/>
      <url>/2023/01/14/%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="我心里的那个女孩"><a href="#我心里的那个女孩" class="headerlink" title="我心里的那个女孩"></a>我心里的那个女孩</h5><p>  或许我会忘记我们的很多细节了，时间会冲淡很多东西，但是，<code>杨诗琦</code>这个名字真的会毕生难忘，这个女孩是我的青春，更是像很多人一样，留在青春的遗憾，不知道未来会这么样，但是至少在目前看来是这样的。</p><p><a href="chushi.jpg"></a></p><p>XHR，Fetch<br>用户代理<br>浏览器能力：<br>自动发送请求的能力<br>自动解析</p><p>如果使用了<img> <vedio> <audio> <script> <css>都是自动调用form请求<br>用户点击了页面刷新，就会发送一个新的请求</p><p>重点；<br>浏览器的约定<br>当发送了GET请求时候，浏览器不会带上请求体，任何请求体都会被干掉<br>服务器看得到你的请求体，但是不会理会，只是协议上允许GET发送请求体</p><p>浏览器对行头的大小是有限制的，但是http协议没有固定规定<br>get请求放在行里面的，所有是由规定大小的，但是post请求放在体里面是没有限制大小的<br>URL地址编码，会把”阿斯克“字符，浏览器地址栏显示中文，其实计算机内部传输的是URL地址编码</p><p>get请求方便分享页面，但是post请求不便于分享数据，分享出去请求体没有分享出去<br>post请求数据不会保存在浏览器的</p><h3 id="自动解析响应的能力"><a href="#自动解析响应的能力" class="headerlink" title="自动解析响应的能力"></a>自动解析响应的能力</h3><p>XHR 和 Feach 两个都属于ajax的<br>ajax是调用浏览器的一个模板<br>var xhr = new XMLHTTPRequest();<br>xhr.open();<br>xhr.setRequest();<br>xhr.send();</p><p>js 代码执行，浏览器必须卡死，不能动其他的东西<br>js 的promise的东西</p><p>程序报错：<br>可预料，一定要处理的<br>不可预料，服务器宕机，断网等</p><p>token 令牌<br>出入证就是一种token令牌，</p><p>发送请求的时候就是要设置一个令牌：<br>Authorization: //这个令牌地址不一定，看开发过程中后端要放在哪里</p><p>http协议是一种无状态的协议</p><p>第三节课的内容</p><p>同源策略：<br>就是一套安全机制<br>同源策略对同源资源开放，对<br>两个URL地址完全相同，就是同源，否则就是异元<br>（前端的代码对用户是可见的，前端是不做加密的）<br>验证码不要写前端</p><p>跨源三种场景<br>网络通信：<br>a元素跳跃，加载css，js，图片，ajax等等<br>JS API<br>window.open  window.parent  iframe.contentWindow等等<br>存储<br>WebStorage IndexedDB 等</p><p>同源请求没有任何限制</p><p>跨域的前提条件：在浏览器里面发起的请求才会有跨域问题，“同源”就是浏览器搞出来的<br>脱离了浏览器就没有跨域的问题</p><p>跨域不一定引发问题<br>CORS<br>JSONP<br>代理</p><p>get 和 post 区别<br>根据RFC7231规定，get和post只是请求行的第一个单词，只是表达了不同的语义</p><p>服务器是程序，计算机是物理设备<br>很多bug就是在开发环境没有什么问题，但是一到生产环境（一般指linux）就会出现很多问题<br>这个一般就是代理出的问题<br>生产环境是没有话语的<br>原则：就是跟生产环境保持一致</p></script></audio></vedio></p>]]></content>
      
      
      <categories>
          
          <category> 我的青春 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端网络</title>
      <link href="/2023/01/14/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/01/14/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>学习要点</strong>：</p><ul><li>明白网络在计算机中发挥的作用，分层模型</li><li>使用<code>Ajax</code>做基本操作，</li><li>计算机网络中跨域问题</li></ul><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a><center>理论</center></h4><p><strong>理论的重要性</strong><br>开发过程找不到bug，原因就是理论不牢找不到问题<br>网络部分的理论是非常多而复杂，<br>实践操作的目的就是去理解理论知识点<br>网络解决的问题是两个程序之间交换数据</p><p>[TOC] <strong>分层模型</strong><br>每层相对独立，只解决自己的问题<br>每层无需考虑上层的交付<br>每层有多种解决方案<br>在上一层基础上加上点东西</p><p><strong>五层模型</strong><br><font color="#0099ff">应用层</font>，应用具体消息<strong>格式</strong>（协议就是一个标准）<br><font color="#0099ff">传输层</font>，如何保证消息<strong>可靠传送</strong><br><font color="#0099ff">网络层</font>，就是如何在网络中找到对方 <strong>IP</strong>（目前通讯地址可变） 路由器<br><font color="#0099ff">数据链路层</font>，如何在一个子网中找到对方 <strong>Mac</strong> （身份证号不可变） 交换机<br><font color="#0099ff">物理层</font>，上面给我的东西我要用什么<strong>信号表述</strong></p><p>—<em>国际OSI七层模型就是在应用层和传输层加多一个表示层和会话层</em>—</p><p>[toc]UML用于定位网络<font color="#0099ff"> 服务 </font>，就是一个<strong>字符串</strong><br>URL（uniform resource locator，统一资源定位符）用于定位网络服务</p><p><img src="http://mdrs.yuanjin.tech/img/202301121041726.png" alt="image-20230112104100679"></p><p>URL是一个固定格式的字符串<br><em>表示形式</em></p><p><img src="http://mdrs.yuanjin.tech/img/202301121029498.png" alt="URL流程表示图"></p><p>它表达了：</p><p>从网络中<font color="#0099ff">哪台计算机（domain）</font>中的<font color="#0099ff">哪个程序（port）</font>寻找<font color="#0099ff">哪个服务（path）</font>，并注明了获取服务的<font color="#0099ff">具体细节（path）</font>，以及要用什么样的<font color="#0099ff">协议通信（schema）</font></p><!-- http默认端口：80 ，https默认端口：443没有写路径的时候，就是最后面会有一个斜杠，就是默认地址https://www.baidu.com/不然浏览器也会默认加上一个/ --><ul><li>当协议是<code>http</code>端口为<code>80</code>时，端口可以省略</li><li>当协议是<code>https</code>端口为<code>443</code>时，端口可以省略</li><li><code>schema</code>、<code>domain</code>、<code>path</code>是必填的，其他的根据具体的要求填写</li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><ul><li>传递消息的<font color="#0099ff">模式</font></li><li>传递消息的<font color="#0099ff">格式</font><br><em>发起者是客户端client，接收者是服务器server（<strong>舔狗和女神</strong>）</em></li><li>格式<br>请求行Line      客户端发送的是纯文本<br>请求头Header<br>请求体Body</li></ul><p>请求方式 post（提交） / get（获取） / delete（删除） / put（修改）</p><blockquote><p>使用情况：<br><font color="#0099ff">获取</font>数据一般使用<code>GET</code><br><font color="#0099ff">提交</font>数据一般使用<code>POST</code><br>各种<font color="#0099ff">静态资源</font>的获取，一般使用<code>GET</code></p></blockquote><h5 id="请求方法之间只有语义的区别"><a href="#请求方法之间只有语义的区别" class="headerlink" title="请求方法之间只有语义的区别"></a>请求方法之间<strong>只有</strong>语义的区别</h5><h4 id="请求头：host"><a href="#请求头：host" class="headerlink" title="请求头：host"></a>请求头：host</h4><p>可以定义一种请求格式，官方没有特定要求<br><code>Host</code>标注了<code>URL</code>地址中的<code>Domain + Port</code><br>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST:study.baidu.com</span><br></pre></td></tr></tbody></table></figure><h4 id="请求头：Content-Type"><a href="#请求头：Content-Type" class="headerlink" title="请求头：Content-Type"></a>请求头：Content-Type</h4><p>比如，请求体的数据为<code>loginId:admin, loginPwd:123456</code>，请求体可以用不同的格式发出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">loginId=admin&amp;loginPwd=123123</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">{ "loginId": "admin", "loginPwd": "123123" }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryraPtlntBIqy4X2Ho</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryraPtlntBIqy4X2Ho</span><br><span class="line">Content-Disposition: form-data; name="loginId"</span><br><span class="line"></span><br><span class="line">admin</span><br><span class="line">------WebKitFormBoundaryraPtlntBIqy4X2Ho</span><br><span class="line">Content-Disposition: form-data; name="loginPwd"</span><br><span class="line"></span><br><span class="line">123456</span><br><span class="line">------WebKitFormBoundaryraPtlntBIqy4X2Ho--</span><br></pre></td></tr></tbody></table></figure><p><code>Content-Type</code>标注了附带的响应体是什么格式<br>常见的值有：</p><ol><li><code>text/plain</code>: 普通的纯文本</li><li><code>text/html</code>：html文档</li><li><code>text/javascript</code> 或 <code>application/javascript</code>：js代码</li><li><code>text/css</code>：css代码</li><li><code>image/jpeg</code>：jpg图片</li><li><code>attachment</code>：附件</li><li>其他<code>MIME</code>类型<br>tip：<br>这个没有固定标准</li></ol><h4 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h4><p>常用的响应码：<br><img src="http://mdrs.yuanjin.tech/img/202301121310570.png" alt="响应码标识"></p><ul><li><p><strong>200 OK：一切正常。</strong></p></li><li><p><strong>301 Moved Permanently：资源已被永久重定向。</strong></p><p> <code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我已经永远的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了响应头的Location中了</code></p><blockquote><p>试试请求：<a href="http://www.douyutv.com/">www.douyutv.com</a></p></blockquote></li><li><p><strong>302 Found：资源已被临时重定向。</strong></p><p> <code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我临时的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了请求头的Location中了</code></p></li><li><p><strong>304 Not Modified：文档内容未被修改。</strong></p><p> <code>你的请求我收到了，你要的东西跟之前是一样的，没有任何的变化，所以我就不给你结果了，你自己就用以前的吧。啥？你没有缓存以前的内容，关我啥事</code></p></li><li><p><strong>400 Bad Request：语义有误，当前请求无法被服务器理解。</strong></p><p> <code>服务器无法解析请求报文</code></p></li><li><p>403 Forbidden：服务器拒绝执行。**</p><p> <code>服务器不给东西给你</code></p></li><li><p><strong>404 Not Found：资源不存在。</strong></p><p> <code>你的请求我收到了，但我没有你要的东西</code></p></li><li><p><strong>500 Internal Server Error：服务器内部错误。</strong></p><p> <code>你的请求我已收到，但这道题我不会，解不出来，先睡了</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Make you first blog</title>
      <link href="/2023/01/11/My-first-blog/"/>
      <url>/2023/01/11/My-first-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>hexo</code>是一个静态博客搭建框架，由 javaScript 实现，所以要调用到js服务端的node环境，与之相同的有：<br><code>hugo</code> (go语言实现的框架，大量信息情况下速度比hexo快)<br>除了静态博客框架，还有<code>WordPress</code>动态博客框架，可以放置到服务器根据用户需求注册账户等服务器端操作</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p><u>默认git，node，npm镜像配置完成</u><br>创建一个 blog 文件夹存放博客文件<br>首先要安装 <code>node npm</code> 两个服务<br>使用 npm 全局安装 <code>hexo-cli</code> 服务</p><p>###基本 hexo 命令使用<br><code>hexo init</code><strong>初始化</strong> hexo 文件，给定基础配置<br><code>hexo s</code> (start)<strong>启动</strong>本地博客，默认端口号: <code>localhost:4000</code><br><code>hexo n</code> (new)<strong>创建</strong>一个新的博客文章<br><code>hexo clean</code> (清理)写完博客文章后，<strong>清理数据</strong><br><code>hexo g</code> (刷新)对数据进行<strong>刷新</strong><br><code>hexo d</code> <strong>提交</strong>到github仓库<br><code>hexo new page </code><strong>创建page</strong>，就是创建一个新文件夹<br><code>hexo new fileName</code><strong>创建文件</strong>,文件创建在<code>/sourse/_post</code>下</p><h3 id="部署到-github-仓库"><a href="#部署到-github-仓库" class="headerlink" title="部署到 github 仓库"></a>部署到 github 仓库</h3><p>1.在自己的 github 上面<em>搭建一个仓库</em>，注意：<code>仓库名要是自己的用户名.github.io </code><br>2.使用 npm 装一个 git <em>部署插件</em> 命令：<code>npm install -g -save hexo-deployer-git </code><br>3.<em>修改配置</em> _config.yml 文件的 deploy：</p><blockquote><p>type: git<br>repo: github仓库http地址<br>branch: masten  (指向空指针的意思) </p></blockquote><p>Tip：<br>如果显示 <code>not fround git</code> 说明插件没安装好,再次尝试安装<br>window 电脑不需要再使用 github 用户密码登陆，直接推到远端<br>但是 linux 和 unix 相反</p><h3 id="修改主题，进行自定义"><a href="#修改主题，进行自定义" class="headerlink" title="修改主题，进行自定义"></a>修改主题，进行自定义</h3><p><code>clone</code> 上面的主题到：<code>/themes</code>里面<br>修改主题文件还是 _config.yml 内：</p><blockquote><p>theme：landspace(修改)<br>剩下的看文档介绍自定义主题</p></blockquote><h4 id="hexo框架操作注意："><a href="#hexo框架操作注意：" class="headerlink" title="hexo框架操作注意："></a>hexo框架操作注意：</h4><ul><li>window系统要安装git</li></ul><ul><li>必须是通过hexo命令创建的文件才可以被使用</li><li>我使用的是<code>hexo-theme-matery</code>主题，该主题分类关键字在页面中的<code>category</code>，在<code>_config.yml</code> 文件中配置命名，<code>/fileName/name/</code>fileName是用hexo命令创建的</li><li>我所使用主题下分类基本都在“分类”栏下，</li><li>hexo生成文件不可以直接修改文件名称</li><li>在hexo的根目录下，打开管理员命令行端口</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><code>hexo d</code> 命令使用：npm包下面的<code>hexo-deployer-git@4.0.0</code>插件，该插件本身问题：内存泄漏或资源竞争问题（连续多次提交重构容易造成冲突会崩溃出现<code>Error:spawn failed</code>）。对此下策<code>npm uninstall</code>再<code>cnpm install hexo-deployer-git --save</code><br><code>github actions</code>里面查看当前重构推送详情</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>@CodeSheep<br>@fi3ework</p>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
